{
  "version": 3,
  "sources": ["../../@sgratzl/boxplots/src/kde.ts", "../../@sgratzl/boxplots/src/quantiles.ts", "../../@sgratzl/boxplots/src/boxplot.ts", "../../@sgratzl/chartjs-chart-boxplot/src/data.ts", "../../@sgratzl/chartjs-chart-boxplot/src/elements/base.ts", "../../@sgratzl/chartjs-chart-boxplot/src/elements/BoxAndWiskers.ts", "../../@sgratzl/chartjs-chart-boxplot/src/elements/Violin.ts", "../../@sgratzl/chartjs-chart-boxplot/src/animation.ts", "../../@sgratzl/chartjs-chart-boxplot/src/tooltip.ts", "../../@sgratzl/chartjs-chart-boxplot/src/controllers/StatsBase.ts", "../../@sgratzl/chartjs-chart-boxplot/src/controllers/patchController.ts", "../../@sgratzl/chartjs-chart-boxplot/src/controllers/BoxPlotController.ts", "../../@sgratzl/chartjs-chart-boxplot/src/controllers/ViolinController.ts"],
  "sourcesContent": ["const HELPER = Math.sqrt(2 * Math.PI);\n\n// See <http://en.wikipedia.org/wiki/Kernel_(statistics)>.\nfunction gaussian(u: number) {\n  return Math.exp(-0.5 * u * u) / HELPER;\n}\n\nfunction toSampleVariance(variance: number, len: number) {\n  return (variance * len) / (len - 1);\n}\n\n/**\n *\n * The [\"normal reference distribution\"\n * rule-of-thumb](https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/bandwidth.nrd.html),\n * a commonly used version of [Silverman's\n * rule-of-thumb](https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator).\n */\nfunction nrd(iqr: number, variance: number, len: number) {\n  let s = Math.sqrt(toSampleVariance(variance, len));\n  if (typeof iqr === 'number') {\n    s = Math.min(s, iqr / 1.34);\n  }\n  return 1.06 * s * Math.pow(len, -0.2);\n}\n\nexport type KernelDensityEstimator = (v: number) => number;\n\nexport default function kde(stats: {\n  items: ArrayLike<number>;\n  iqr: number;\n  variance: number;\n}): KernelDensityEstimator {\n  const len = stats.items.length;\n  const bandwidth = nrd(stats.iqr, stats.variance, len);\n\n  return (x: number) => {\n    let i = 0;\n    let sum = 0;\n    for (i = 0; i < len; i++) {\n      const v = stats.items[i];\n      sum += gaussian((x - v) / bandwidth);\n    }\n    return sum / bandwidth / len;\n  };\n}\n", "export interface QuantilesResult {\n  q1: number;\n  median: number;\n  q3: number;\n}\n\n/**\n * computes the boxplot stats using the given interpolation function if needed\n * @param {number[]} arr sorted array of number\n * @param {(i: number, j: number, fraction: number)} interpolate interpolation function\n */\nexport function quantilesInterpolate(\n  arr: ArrayLike<number>,\n  length: number,\n  interpolate: (i: number, j: number, fraction: number) => number\n): QuantilesResult {\n  const n1 = length - 1;\n  const compute = (q: number) => {\n    const index = q * n1;\n    const lo = Math.floor(index);\n    const h = index - lo;\n    const a = arr[lo];\n\n    return h === 0 ? a : interpolate(a, arr[Math.min(lo + 1, n1)], h);\n  };\n\n  return {\n    q1: compute(0.25),\n    median: compute(0.5),\n    q3: compute(0.75),\n  };\n}\n\n/**\n * Uses R's quantile algorithm type=7.\n * https://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population\n */\nexport function quantilesType7(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  return quantilesInterpolate(arr, length, (a, b, alpha) => a + alpha * (b - a));\n}\n\n/**\n * ‘linear’: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j.\n * (same as type 7)\n */\nexport function quantilesLinear(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  return quantilesInterpolate(arr, length, (i, j, fraction) => i + (j - i) * fraction);\n}\n\n/**\n * ‘lower’: i.\n */\nexport function quantilesLower(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  return quantilesInterpolate(arr, length, (i) => i);\n}\n\n/**\n * 'higher': j.\n */\nexport function quantilesHigher(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  return quantilesInterpolate(arr, length, (_, j) => j);\n}\n\n/**\n * ‘nearest’: i or j, whichever is nearest\n */\nexport function quantilesNearest(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  return quantilesInterpolate(arr, length, (i, j, fraction) => (fraction < 0.5 ? i : j));\n}\n\n/**\n * ‘midpoint’: (i + j) / 2\n */\nexport function quantilesMidpoint(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  return quantilesInterpolate(arr, length, (i, j) => (i + j) * 0.5);\n}\n\n/**\n * The hinges equal the quartiles for odd n (where n <- length(x))\n * and differ for even n. Whereas the quartiles only equal observations\n * for n %% 4 == 1 (n = 1 mod 4), the hinges do so additionally\n * for n %% 4 == 2 (n = 2 mod 4), and are in the middle of\n * two observations otherwise.\n */\nexport function quantilesFivenum(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  // based on R fivenum\n  const n = length;\n\n  // assuming R 1 index system, so arr[1] is the first element\n  const n4 = Math.floor((n + 3) / 2) / 2;\n  const compute = (d: number) => 0.5 * (arr[Math.floor(d) - 1] + arr[Math.ceil(d) - 1]);\n\n  return {\n    q1: compute(n4),\n    median: compute((n + 1) / 2),\n    q3: compute(n + 1 - n4),\n  };\n}\n\n/**\n * alias for quantilesFivenum\n * @param arr\n * @param length\n */\nexport function quantilesHinges(arr: ArrayLike<number>, length = arr.length): QuantilesResult {\n  return quantilesFivenum(arr, length);\n}\n", "import kde, { type KernelDensityEstimator } from './kde';\nimport { quantilesType7 } from './quantiles';\n\nexport interface IBoxPlot {\n  /**\n   * minimum value in the given data\n   */\n  readonly min: number;\n  /**\n   * maximum value in the given data\n   */\n  readonly max: number;\n  /**\n   * median value in the given data\n   */\n  readonly median: number;\n  /**\n   * 25% quantile\n   */\n  readonly q1: number;\n  /**\n   * 75% quantile\n   */\n  readonly q3: number;\n\n  /**\n   * inter quantile range (q3 - q1)\n   */\n  readonly iqr: number;\n  /**\n   * whisker / fence below the 25% quantile (lower one)\n   * by default is computed as the smallest element that satisfies (e >= q1 - 1.5IQR && e <= q1)\n   */\n  readonly whiskerLow: number;\n  /**\n   * whisker / fence above the 75% quantile (upper one)\n   * by default is computed as the largest element that satisfies (e <= q3 + 1.5IQR && e >= q1)\n   */\n  readonly whiskerHigh: number;\n  /**\n   * outliers that are outside of the whiskers on both ends\n   */\n  readonly outlier: readonly number[];\n\n  /**\n   * arithmetic mean\n   */\n  readonly mean: number;\n\n  /**\n   * variance\n   */\n  readonly variance: number;\n\n  /**\n   * number of missing values (NaN, null, undefined) in the data\n   */\n  readonly missing: number;\n  /**\n   * number of values (valid + missing)\n   */\n  readonly count: number;\n  /**\n   * array like (array or typed array) of all valid items\n   */\n  readonly items: ArrayLike<number>;\n\n  readonly kde: KernelDensityEstimator;\n}\n\nexport declare interface QuantileMethod {\n  (arr: ArrayLike<number>, length: number): { q1: number; median: number; q3: number };\n}\n\nexport declare type BoxplotStatsOptions = {\n  /**\n   * specify the coefficient for the whiskers, use <=0 for getting min/max instead\n   * the coefficient will be multiplied by the IQR\n   * @default 1.5\n   */\n  coef?: number;\n\n  /**\n   * specify the quantile method to use\n   * @default quantilesType7\n   */\n  quantiles?: QuantileMethod;\n\n  /**\n   * defines that it can be assumed that the array is sorted and just contains valid numbers\n   * (which will avoid unnecessary checks and sorting)\n   * @default false\n   */\n  validAndSorted?: boolean;\n\n  /**\n   * whiskers mode whether to compute the nearest element which is bigger/smaller than low/high whisker or\n   * the exact value\n   * @default 'nearest'\n   */\n  whiskersMode?: 'nearest' | 'exact';\n\n  /**\n   * delta epsilon to compare\n   * @default 10e-3\n   */\n  eps?: number;\n};\n\nfunction createSortedData(data: readonly number[] | Float32Array | Float64Array) {\n  let valid = 0;\n  const { length } = data;\n\n  const vs = data instanceof Float64Array ? new Float64Array(length) : new Float32Array(length);\n\n  for (let i = 0; i < length; i += 1) {\n    const v = data[i];\n    if (v == null || Number.isNaN(v)) {\n      continue;\n    }\n    vs[valid] = v;\n    valid += 1;\n  }\n\n  const missing = length - valid;\n\n  if (valid === 0) {\n    return {\n      min: Number.NaN,\n      max: Number.NaN,\n      missing,\n      s: [],\n    };\n  }\n\n  // add comparator since the polyfill doesn't to a real sorting\n  const validData = valid === length ? vs : vs.subarray(0, valid);\n  // sort in place\n\n  validData.sort((a, b) => (a === b ? 0 : a < b ? -1 : 1));\n\n  // use real number for better precision\n  const min = validData[0];\n  const max = validData[validData.length - 1];\n\n  return {\n    min,\n    max,\n    missing,\n    s: validData,\n  };\n}\n\nfunction withSortedData(data: readonly number[] | Float32Array | Float64Array) {\n  if (data.length === 0) {\n    return {\n      min: Number.NaN,\n      max: Number.NaN,\n      missing: 0,\n      s: [],\n    };\n  }\n  const min = data[0];\n  const max = data[data.length - 1];\n\n  return {\n    min,\n    max,\n    missing: 0,\n    s: data,\n  };\n}\n\nfunction computeWhiskers(\n  s: ArrayLike<number>,\n  valid: number,\n  min: number,\n  max: number,\n  { eps, quantiles, coef, whiskersMode }: Required<BoxplotStatsOptions>\n) {\n  const same = (a: number, b: number) => Math.abs(a - b) < eps;\n\n  const { median, q1, q3 } = quantiles(s, valid);\n  const iqr = q3 - q1;\n  const isCoefValid = typeof coef === 'number' && coef > 0;\n\n  let whiskerLow = isCoefValid ? Math.max(min, q1 - coef * iqr) : min;\n  let whiskerHigh = isCoefValid ? Math.min(max, q3 + coef * iqr) : max;\n\n  const outlierLow: number[] = [];\n  // look for the closest value which is bigger than the computed left\n  for (let i = 0; i < valid; i += 1) {\n    const v = s[i];\n    if (v >= whiskerLow || same(v, whiskerLow)) {\n      if (whiskersMode === 'nearest') {\n        whiskerLow = v;\n      }\n      break;\n    }\n    // outlier\n    if (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], v)) {\n      outlierLow.push(v);\n    }\n  }\n  // look for the closest value which is smaller than the computed right\n  const reversedOutlierHigh: number[] = [];\n  for (let i = valid - 1; i >= 0; i -= 1) {\n    const v = s[i];\n    if (v <= whiskerHigh || same(v, whiskerHigh)) {\n      if (whiskersMode === 'nearest') {\n        whiskerHigh = v;\n      }\n      break;\n    }\n    // outlier\n    if (\n      (reversedOutlierHigh.length === 0 || !same(reversedOutlierHigh[reversedOutlierHigh.length - 1], v)) &&\n      (outlierLow.length === 0 || !same(outlierLow[outlierLow.length - 1], v))\n    ) {\n      reversedOutlierHigh.push(v);\n    }\n  }\n  const outlier = outlierLow.concat(reversedOutlierHigh.reverse());\n\n  return {\n    median,\n    q1,\n    q3,\n    iqr,\n    outlier,\n    whiskerHigh,\n    whiskerLow,\n  };\n}\n\nfunction computeStats(s: ArrayLike<number>, valid: number) {\n  let mean = 0;\n\n  for (let i = 0; i < valid; i++) {\n    const v = s[i];\n    mean += v;\n  }\n  mean /= valid;\n\n  let variance = 0;\n  for (let i = 0; i < valid; i++) {\n    const v = s[i];\n    variance += (v - mean) * (v - mean);\n  }\n  variance /= valid;\n\n  return {\n    mean,\n    variance,\n  };\n}\n\nexport default function boxplot(\n  data: readonly number[] | Float32Array | Float64Array,\n  options: BoxplotStatsOptions = {}\n): IBoxPlot {\n  const fullOptions: Required<BoxplotStatsOptions> = {\n    coef: 1.5,\n    eps: 10e-3,\n    quantiles: quantilesType7,\n    validAndSorted: false,\n    whiskersMode: 'nearest',\n    ...options,\n  };\n\n  const { missing, s, min, max } = fullOptions.validAndSorted ? withSortedData(data) : createSortedData(data);\n\n  const invalid: IBoxPlot = {\n    min: Number.NaN,\n    max: Number.NaN,\n    mean: Number.NaN,\n    missing,\n    iqr: Number.NaN,\n    count: data.length,\n    whiskerHigh: Number.NaN,\n    whiskerLow: Number.NaN,\n    outlier: [],\n    median: Number.NaN,\n    q1: Number.NaN,\n    q3: Number.NaN,\n    variance: 0,\n    items: [],\n    kde: () => 0,\n  };\n  const valid = data.length - missing;\n\n  if (valid === 0) {\n    return invalid;\n  }\n  const result: Omit<IBoxPlot, 'kde'> = {\n    min,\n    max,\n    count: data.length,\n    missing,\n    items: s,\n    ...computeStats(s, valid),\n    ...computeWhiskers(s, valid, min, max, fullOptions),\n  };\n  return {\n    ...result,\n    kde: kde(result),\n  };\n}\n", "import {\n  boxplot as boxplots,\n  quantilesFivenum,\n  quantilesHigher,\n  quantilesHinges,\n  quantilesLinear,\n  quantilesLower,\n  quantilesMidpoint,\n  quantilesNearest,\n  quantilesType7,\n} from '@sgratzl/boxplots';\n\nexport {\n  quantilesFivenum,\n  quantilesHigher,\n  quantilesHinges,\n  quantilesLinear,\n  quantilesLower,\n  quantilesMidpoint,\n  quantilesNearest,\n  quantilesType7,\n} from '@sgratzl/boxplots';\n\nexport interface IBaseStats {\n  min: number;\n  max: number;\n  q1: number;\n  q3: number;\n  median: number;\n  mean: number;\n  items: readonly number[];\n  outliers: readonly number[];\n}\n\nexport interface IBoxPlot extends IBaseStats {\n  whiskerMax: number;\n  whiskerMin: number;\n}\n\nexport interface IKDEPoint {\n  v: number;\n  estimate: number;\n}\n\nexport interface IViolin extends IBaseStats {\n  maxEstimate: number;\n  coords: IKDEPoint[];\n}\n\n/**\n * compute the whiskers\n * @param boxplot\n * @param {number[]} arr sorted array\n * @param {number} coef\n */\nexport function whiskers(\n  boxplot: IBoxPlot,\n  arr: number[] | null,\n  coef = 1.5\n): { whiskerMin: number; whiskerMax: number } {\n  const iqr = boxplot.q3 - boxplot.q1;\n  // since top left is max\n  const coefValid = typeof coef === 'number' && coef > 0;\n  let whiskerMin = coefValid ? Math.max(boxplot.min, boxplot.q1 - coef * iqr) : boxplot.min;\n  let whiskerMax = coefValid ? Math.min(boxplot.max, boxplot.q3 + coef * iqr) : boxplot.max;\n\n  if (Array.isArray(arr)) {\n    // compute the closest real element\n    for (let i = 0; i < arr.length; i += 1) {\n      const v = arr[i];\n      if (v >= whiskerMin) {\n        whiskerMin = v;\n        break;\n      }\n    }\n    for (let i = arr.length - 1; i >= 0; i -= 1) {\n      const v = arr[i];\n      if (v <= whiskerMax) {\n        whiskerMax = v;\n        break;\n      }\n    }\n  }\n\n  return {\n    whiskerMin,\n    whiskerMax,\n  };\n}\n\nexport type QuantileMethod =\n  | 7\n  | 'quantiles'\n  | 'hinges'\n  | 'fivenum'\n  | 'linear'\n  | 'lower'\n  | 'higher'\n  | 'nearest'\n  | 'midpoint'\n  | ((arr: ArrayLike<number>, length?: number | undefined) => { q1: number; median: number; q3: number });\n\nexport interface IBaseOptions {\n  /**\n   * statistic measure that should be used for computing the minimal data limit\n   * @default 'min'\n   */\n  minStats?: 'min' | 'q1' | 'whiskerMin';\n\n  /**\n   * statistic measure that should be used for computing the maximal data limit\n   * @default 'max'\n   */\n  maxStats?: 'max' | 'q3' | 'whiskerMax';\n\n  /**\n   * from the R doc: this determines how far the plot ‘whiskers’ extend out from\n   * the box. If coef is positive, the whiskers extend to the most extreme data\n   * point which is no more than coef times the length of the box away from the\n   * box. A value of zero causes the whiskers to extend to the data extremes\n   * @default 1.5\n   */\n  coef?: number;\n\n  /**\n   * the method to compute the quantiles.\n   *\n   * 7, 'quantiles': the type-7 method as used by R 'quantiles' method.\n   * 'hinges' and 'fivenum': the method used by R 'boxplot.stats' method.\n   * 'linear': the interpolation method 'linear' as used by 'numpy.percentile' function\n   * 'lower': the interpolation method 'lower' as used by 'numpy.percentile' function\n   * 'higher': the interpolation method 'higher' as used by 'numpy.percentile' function\n   * 'nearest': the interpolation method 'nearest' as used by 'numpy.percentile' function\n   * 'midpoint': the interpolation method 'midpoint' as used by 'numpy.percentile' function\n   * @default 7\n   */\n  quantiles?: QuantileMethod;\n\n  /**\n   * the method to compute the whiskers.\n   *\n   * 'nearest': with this mode computed whisker values will be replaced with nearest real data points\n   * 'exact': with this mode exact computed whisker values will be displayed on chart\n   * @default 'nearest'\n   */\n  whiskersMode?: 'nearest' | 'exact';\n}\n\nexport type IBoxplotOptions = IBaseOptions;\n\nexport interface IViolinOptions extends IBaseOptions {\n  /**\n   * number of points that should be samples of the KDE\n   * @default 100\n   */\n  points: number;\n}\n\n/**\n * @hidden\n */\nexport const defaultStatsOptions: Required<Omit<IBaseOptions, 'minStats' | 'maxStats'>> = {\n  coef: 1.5,\n  quantiles: 7,\n  whiskersMode: 'nearest',\n};\n\nfunction determineQuantiles(q: QuantileMethod) {\n  if (typeof q === 'function') {\n    return q;\n  }\n  const lookup = {\n    hinges: quantilesHinges,\n    fivenum: quantilesFivenum,\n    7: quantilesType7,\n    quantiles: quantilesType7,\n    linear: quantilesLinear,\n    lower: quantilesLower,\n    higher: quantilesHigher,\n    nearest: quantilesNearest,\n    midpoint: quantilesMidpoint,\n  };\n  return lookup[q] || quantilesType7;\n}\n\nfunction determineStatsOptions(options?: IBaseOptions) {\n  const coef = options == null || typeof options.coef !== 'number' ? defaultStatsOptions.coef : options.coef;\n  const q = options == null || options.quantiles == null ? quantilesType7 : options.quantiles;\n  const quantiles = determineQuantiles(q);\n  const whiskersMode =\n    options == null || typeof options.whiskersMode !== 'string'\n      ? defaultStatsOptions.whiskersMode\n      : options.whiskersMode;\n  return {\n    coef,\n    quantiles,\n    whiskersMode,\n  };\n}\n\n/**\n * @hidden\n */\nexport function boxplotStats(arr: readonly number[] | Float32Array | Float64Array, options: IBaseOptions): IBoxPlot {\n  const vs =\n    typeof Float64Array !== 'undefined' && !(arr instanceof Float32Array || arr instanceof Float64Array)\n      ? Float64Array.from(arr)\n      : arr;\n  const r = boxplots(vs, determineStatsOptions(options));\n  return {\n    items: Array.from(r.items),\n    outliers: r.outlier,\n    whiskerMax: r.whiskerHigh,\n    whiskerMin: r.whiskerLow,\n    max: r.max,\n    median: r.median,\n    mean: r.mean,\n    min: r.min,\n    q1: r.q1,\n    q3: r.q3,\n  };\n}\n\nfunction computeSamples(min: number, max: number, points: number) {\n  // generate coordinates\n  const range = max - min;\n  const samples: number[] = [];\n  const inc = range / points;\n  for (let v = min; v <= max && inc > 0; v += inc) {\n    samples.push(v);\n  }\n  if (samples[samples.length - 1] !== max) {\n    samples.push(max);\n  }\n  return samples;\n}\n\n/**\n * @hidden\n */\nexport function violinStats(arr: readonly number[], options: IViolinOptions): IViolin | undefined {\n  // console.assert(Array.isArray(arr));\n  if (arr.length === 0) {\n    return undefined;\n  }\n  const vs =\n    typeof Float64Array !== 'undefined' && !(arr instanceof Float32Array || arr instanceof Float64Array)\n      ? Float64Array.from(arr)\n      : arr;\n  const stats = boxplots(vs, determineStatsOptions(options));\n\n  // generate coordinates\n  const samples = computeSamples(stats.min, stats.max, options.points);\n  const coords = samples.map((v) => ({ v, estimate: stats.kde(v) }));\n  const maxEstimate = coords.reduce((a, d) => Math.max(a, d.estimate), Number.NEGATIVE_INFINITY);\n\n  return {\n    max: stats.max,\n    min: stats.min,\n    mean: stats.mean,\n    median: stats.median,\n    q1: stats.q1,\n    q3: stats.q3,\n    items: Array.from(stats.items),\n    coords,\n    outliers: [], // items.filter((d) => d < stats.q1 || d > stats.q3),\n    maxEstimate,\n  };\n}\n\n/**\n * @hidden\n */\nexport function asBoxPlotStats(value: any, options: IBoxplotOptions): IBoxPlot | undefined {\n  if (!value) {\n    return undefined;\n  }\n  if (typeof value.median === 'number' && typeof value.q1 === 'number' && typeof value.q3 === 'number') {\n    // sounds good, check for helper\n    if (typeof value.whiskerMin === 'undefined') {\n      const { coef } = determineStatsOptions(options);\n      const { whiskerMin, whiskerMax } = whiskers(\n        value,\n        Array.isArray(value.items) ? (value.items as number[]).slice().sort((a, b) => a - b) : null,\n        coef\n      );\n      value.whiskerMin = whiskerMin;\n      value.whiskerMax = whiskerMax;\n    }\n    return value;\n  }\n  if (!Array.isArray(value)) {\n    return undefined;\n  }\n  return boxplotStats(value, options);\n}\n\n/**\n * @hidden\n */\n\nexport function asViolinStats(value: any, options: IViolinOptions): IViolin | undefined {\n  if (!value) {\n    return undefined;\n  }\n  if (typeof value.median === 'number' && Array.isArray(value.coords)) {\n    return value;\n  }\n  if (!Array.isArray(value)) {\n    return undefined;\n  }\n  return violinStats(value, options);\n}\n\n/**\n * @hidden\n */\nexport function rnd(seed = Date.now()): () => number {\n  // Adapted from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n  let s = seed;\n  return () => {\n    s = (s * 9301 + 49297) % 233280;\n    return s / 233280;\n  };\n}\n", "import { Element } from 'chart.js';\nimport { drawPoint } from 'chart.js/helpers';\nimport { rnd } from '../data';\nimport type { ExtendedTooltip } from '../tooltip';\n\nexport interface IStatsBaseOptions {\n  /**\n   * @default see rectangle\n   * scriptable\n   * indexable\n   */\n  backgroundColor: string;\n\n  /**\n   * @default see rectangle\n   * scriptable\n   * indexable\n   */\n  borderColor: string;\n\n  /**\n   * @default 1\n   * scriptable\n   * indexable\n   */\n  borderWidth: number;\n\n  /**\n   * item style used to render outliers\n   * @default circle\n   */\n  outlierStyle:\n    | 'circle'\n    | 'triangle'\n    | 'rect'\n    | 'rectRounded'\n    | 'rectRot'\n    | 'cross'\n    | 'crossRot'\n    | 'star'\n    | 'line'\n    | 'dash';\n\n  /**\n   * radius used to render outliers\n   * @default 2\n   * scriptable\n   * indexable\n   */\n  outlierRadius: number;\n\n  /**\n   * @default see rectangle.backgroundColor\n   * scriptable\n   * indexable\n   */\n  outlierBackgroundColor: string;\n\n  /**\n   * @default see rectangle.borderColor\n   * scriptable\n   * indexable\n   */\n  outlierBorderColor: string;\n  /**\n   * @default 1\n   * scriptable\n   * indexable\n   */\n  outlierBorderWidth: number;\n\n  /**\n   * item style used to render items\n   * @default circle\n   */\n  itemStyle:\n    | 'circle'\n    | 'triangle'\n    | 'rect'\n    | 'rectRounded'\n    | 'rectRot'\n    | 'cross'\n    | 'crossRot'\n    | 'star'\n    | 'line'\n    | 'dash';\n\n  /**\n   * radius used to render items\n   * @default 0 so disabled\n   * scriptable\n   * indexable\n   */\n  itemRadius: number;\n\n  /**\n   * background color for items\n   * @default see rectangle.backgroundColor\n   * scriptable\n   * indexable\n   */\n  itemBackgroundColor: string;\n\n  /**\n   * border color for items\n   * @default see rectangle.borderColor\n   * scriptable\n   * indexable\n   */\n  itemBorderColor: string;\n\n  /**\n   * border width for items\n   * @default 0\n   * scriptable\n   * indexable\n   */\n  itemBorderWidth: number;\n  /**\n   * hit radius for hit test of items\n   * @default 0\n   * scriptable\n   * indexable\n   */\n  itemHitRadius: number;\n\n  /**\n   * padding that is added around the bounding box when computing a mouse hit\n   * @default 2\n   * scriptable\n   * indexable\n   */\n  hitPadding: number;\n\n  /**\n   * hit radius for hit test of outliers\n   * @default 4\n   * scriptable\n   * indexable\n   */\n  outlierHitRadius: number;\n\n  /**\n   * item style used to render mean dot\n   * @default circle\n   */\n  meanStyle:\n    | 'circle'\n    | 'triangle'\n    | 'rect'\n    | 'rectRounded'\n    | 'rectRot'\n    | 'cross'\n    | 'crossRot'\n    | 'star'\n    | 'line'\n    | 'dash';\n\n  /**\n   * radius used to mean dots\n   * @default 3\n   * scriptable\n   * indexable\n   */\n  meanRadius: number;\n\n  /**\n   * background color for mean dot\n   * @default see rectangle.backgroundColor\n   * scriptable\n   * indexable\n   */\n  meanBackgroundColor: string;\n\n  /**\n   * border color for mean dot\n   * @default see rectangle.borderColor\n   * scriptable\n   * indexable\n   */\n  meanBorderColor: string;\n\n  /**\n   * border width for mean dot\n   * @default 0\n   * scriptable\n   * indexable\n   */\n  meanBorderWidth: number;\n}\n\n/**\n * @hidden\n */\nexport const baseDefaults = {\n  borderWidth: 1,\n\n  outlierStyle: 'circle',\n  outlierRadius: 2,\n  outlierBorderWidth: 1,\n\n  itemStyle: 'circle',\n  itemRadius: 0,\n  itemBorderWidth: 0,\n  itemHitRadius: 0,\n\n  meanStyle: 'circle',\n  meanRadius: 3,\n  meanBorderWidth: 1,\n\n  hitPadding: 2,\n  outlierHitRadius: 4,\n};\n\n/**\n * @hidden\n */\nexport const baseRoutes = {\n  outlierBackgroundColor: 'backgroundColor',\n  outlierBorderColor: 'borderColor',\n  itemBackgroundColor: 'backgroundColor',\n  itemBorderColor: 'borderColor',\n  meanBackgroundColor: 'backgroundColor',\n  meanBorderColor: 'borderColor',\n};\n\n/**\n * @hidden\n */\nexport const baseOptionKeys = /* #__PURE__ */ (() => Object.keys(baseDefaults).concat(Object.keys(baseRoutes)))();\n\nexport interface IStatsBaseProps {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  items: number[];\n  outliers: number[];\n}\n\nexport class StatsBase<T extends IStatsBaseProps & { mean?: number }, O extends IStatsBaseOptions> extends Element<\n  T,\n  O\n> {\n  /**\n   * @hidden\n   */\n  declare _datasetIndex: number;\n\n  /**\n   * @hidden\n   */\n  declare horizontal: boolean;\n\n  /**\n   * @hidden\n   */\n  declare _index: number;\n\n  /**\n   * @hidden\n   */\n  isVertical(): boolean {\n    return !this.horizontal;\n  }\n\n  /**\n   * @hidden\n   */\n  protected _drawItems(ctx: CanvasRenderingContext2D): void {\n    const vert = this.isVertical();\n    const props = this.getProps(['x', 'y', 'items', 'width', 'height', 'outliers']);\n    const { options } = this;\n\n    if (options.itemRadius <= 0 || !props.items || props.items.length <= 0) {\n      return;\n    }\n    ctx.save();\n    ctx.strokeStyle = options.itemBorderColor;\n    ctx.fillStyle = options.itemBackgroundColor;\n    ctx.lineWidth = options.itemBorderWidth;\n    // jitter based on random data\n    // use the dataset index and index to initialize the random number generator\n    const random = rnd(this._datasetIndex * 1000 + this._index);\n\n    const pointOptions = {\n      pointStyle: options.itemStyle,\n      radius: options.itemRadius,\n      borderWidth: options.itemBorderWidth,\n    };\n    const outliers = new Set(props.outliers || []);\n\n    if (vert) {\n      props.items.forEach((v) => {\n        if (!outliers.has(v)) {\n          drawPoint(ctx, pointOptions, props.x - props.width / 2 + random() * props.width, v);\n        }\n      });\n    } else {\n      props.items.forEach((v) => {\n        if (!outliers.has(v)) {\n          drawPoint(ctx, pointOptions, v, props.y - props.height / 2 + random() * props.height);\n        }\n      });\n    }\n    ctx.restore();\n  }\n\n  /**\n   * @hidden\n   */\n  protected _drawOutliers(ctx: CanvasRenderingContext2D): void {\n    const vert = this.isVertical();\n    const props = this.getProps(['x', 'y', 'outliers']);\n    const { options } = this;\n    if (options.outlierRadius <= 0 || !props.outliers || props.outliers.length === 0) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.outlierBackgroundColor;\n    ctx.strokeStyle = options.outlierBorderColor;\n    ctx.lineWidth = options.outlierBorderWidth;\n\n    const pointOptions = {\n      pointStyle: options.outlierStyle,\n      radius: options.outlierRadius,\n      borderWidth: options.outlierBorderWidth,\n    };\n\n    if (vert) {\n      props.outliers.forEach((v) => {\n        drawPoint(ctx, pointOptions, props.x, v);\n      });\n    } else {\n      props.outliers.forEach((v) => {\n        drawPoint(ctx, pointOptions, v, props.y);\n      });\n    }\n\n    ctx.restore();\n  }\n\n  /**\n   * @hidden\n   */\n  protected _drawMeanDot(ctx: CanvasRenderingContext2D): void {\n    const vert = this.isVertical();\n    const props = this.getProps(['x', 'y', 'mean']);\n    const { options } = this;\n    if (options.meanRadius <= 0 || props.mean == null || Number.isNaN(props.mean)) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.meanBackgroundColor;\n    ctx.strokeStyle = options.meanBorderColor;\n    ctx.lineWidth = options.meanBorderWidth;\n\n    const pointOptions = {\n      pointStyle: options.meanStyle,\n      radius: options.meanRadius,\n      borderWidth: options.meanBorderWidth,\n    };\n\n    if (vert) {\n      drawPoint(ctx, pointOptions, props.x, props.mean);\n    } else {\n      drawPoint(ctx, pointOptions, props.mean, props.y);\n    }\n\n    ctx.restore();\n  }\n\n  /**\n   * @hidden\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _getBounds(_useFinalPosition?: boolean): { left: number; top: number; right: number; bottom: number } {\n    // abstract\n    return {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  _getHitBounds(useFinalPosition?: boolean): { left: number; top: number; right: number; bottom: number } {\n    const padding = this.options.hitPadding;\n    const b = this._getBounds(useFinalPosition);\n    return {\n      left: b.left - padding,\n      top: b.top - padding,\n      right: b.right + padding,\n      bottom: b.bottom + padding,\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean): boolean {\n    if (Number.isNaN(this.x) && Number.isNaN(this.y)) {\n      return false;\n    }\n    return (\n      this._boxInRange(mouseX, mouseY, useFinalPosition) ||\n      this._outlierIndexInRange(mouseX, mouseY, useFinalPosition) != null ||\n      this._itemIndexInRange(mouseX, mouseY, useFinalPosition) != null\n    );\n  }\n\n  /**\n   * @hidden\n   */\n  inXRange(mouseX: number, useFinalPosition?: boolean): boolean {\n    const bounds = this._getHitBounds(useFinalPosition);\n    return mouseX >= bounds.left && mouseX <= bounds.right;\n  }\n\n  /**\n   * @hidden\n   */\n  inYRange(mouseY: number, useFinalPosition?: boolean): boolean {\n    const bounds = this._getHitBounds(useFinalPosition);\n    return mouseY >= bounds.top && mouseY <= bounds.bottom;\n  }\n\n  /**\n   * @hidden\n   */\n  protected _outlierIndexInRange(\n    mouseX: number,\n    mouseY: number,\n    useFinalPosition?: boolean\n  ): { index: number; x: number; y: number } | null {\n    const props = this.getProps(['x', 'y'], useFinalPosition);\n    const hitRadius = this.options.outlierHitRadius;\n    const outliers = this._getOutliers(useFinalPosition);\n    const vertical = this.isVertical();\n\n    // check if along the outlier line\n    if ((vertical && Math.abs(mouseX - props.x) > hitRadius) || (!vertical && Math.abs(mouseY - props.y) > hitRadius)) {\n      return null;\n    }\n    const toCompare = vertical ? mouseY : mouseX;\n    for (let i = 0; i < outliers.length; i += 1) {\n      if (Math.abs(outliers[i] - toCompare) <= hitRadius) {\n        return vertical ? { index: i, x: props.x, y: outliers[i] } : { index: i, x: outliers[i], y: props.y };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @hidden\n   */\n  protected _itemIndexInRange(\n    mouseX: number,\n    mouseY: number,\n    useFinalPosition?: boolean\n  ): { index: number; x: number; y: number } | null {\n    const hitRadius = this.options.itemHitRadius;\n    if (hitRadius <= 0) {\n      return null;\n    }\n    const props = this.getProps(['x', 'y', 'items', 'width', 'height', 'outliers'], useFinalPosition);\n    const vert = this.isVertical();\n    const { options } = this;\n\n    if (options.itemRadius <= 0 || !props.items || props.items.length <= 0) {\n      return null;\n    }\n    // jitter based on random data\n    // use the dataset index and index to initialize the random number generator\n    const random = rnd(this._datasetIndex * 1000 + this._index);\n    const outliers = new Set(props.outliers || []);\n\n    if (vert) {\n      for (let i = 0; i < props.items.length; i++) {\n        const y = props.items[i];\n        if (!outliers.has(y)) {\n          const x = props.x - props.width / 2 + random() * props.width;\n          if (Math.abs(x - mouseX) <= hitRadius && Math.abs(y - mouseY) <= hitRadius) {\n            return { index: i, x, y };\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i < props.items.length; i++) {\n        const x = props.items[i];\n        if (!outliers.has(x)) {\n          const y = props.y - props.height / 2 + random() * props.height;\n          if (Math.abs(x - mouseX) <= hitRadius && Math.abs(y - mouseY) <= hitRadius) {\n            return { index: i, x, y };\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @hidden\n   */\n  protected _boxInRange(mouseX: number, mouseY: number, useFinalPosition?: boolean): boolean {\n    const bounds = this._getHitBounds(useFinalPosition);\n    return mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n  }\n\n  /**\n   * @hidden\n   */\n  getCenterPoint(useFinalPosition?: boolean): { x: number; y: number } {\n    const props = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x: props.x,\n      y: props.y,\n    };\n  }\n\n  /**\n   * @hidden\n   */\n  protected _getOutliers(useFinalPosition?: boolean): number[] {\n    const props = this.getProps(['outliers'], useFinalPosition);\n    return props.outliers || [];\n  }\n\n  /**\n   * @hidden\n   */\n  tooltipPosition(\n    eventPosition?: { x: number; y: number } | boolean,\n    tooltip?: ExtendedTooltip\n  ): { x: number; y: number } {\n    if (!eventPosition || typeof eventPosition === 'boolean') {\n      // fallback\n      return this.getCenterPoint();\n    }\n    if (tooltip) {\n      delete tooltip._tooltipOutlier;\n\n      delete tooltip._tooltipItem;\n    }\n\n    //outlier\n    const info = this._outlierIndexInRange(eventPosition.x, eventPosition.y);\n    if (info != null && tooltip) {\n      // hack in the data of the hovered outlier\n\n      tooltip._tooltipOutlier = {\n        index: info.index,\n        datasetIndex: this._datasetIndex,\n      };\n      return {\n        x: info.x,\n        y: info.y,\n      };\n    }\n    // items\n    const itemInfo = this._itemIndexInRange(eventPosition.x, eventPosition.y);\n    if (itemInfo != null && tooltip) {\n      // hack in the data of the hovered outlier\n\n      tooltip._tooltipItem = {\n        index: itemInfo.index,\n        datasetIndex: this._datasetIndex,\n      };\n      return {\n        x: itemInfo.x,\n        y: itemInfo.y,\n      };\n    }\n\n    // fallback\n    return this.getCenterPoint();\n  }\n}\n", "import { BarElement, ChartType, CommonHoverOptions, ScriptableAndArrayOptions, ScriptableContext } from 'chart.js';\nimport {\n  StatsBase,\n  baseDefaults,\n  baseOptionKeys,\n  baseRoutes,\n  type IStatsBaseOptions,\n  type IStatsBaseProps,\n} from './base';\n/**\n * @hidden\n */\nexport const boxOptionsKeys = baseOptionKeys.concat(['medianColor', 'lowerBackgroundColor']);\n\nexport interface IBoxAndWhiskersOptions extends IStatsBaseOptions {\n  /**\n   * separate color for the median line\n   * @default 'transparent' takes the current borderColor\n   * scriptable\n   * indexable\n   */\n  medianColor: string;\n\n  /**\n   * color the lower half (median-q3) of the box in a different color\n   * @default 'transparent' takes the current borderColor\n   * scriptable\n   * indexable\n   */\n  lowerBackgroundColor: string;\n}\n\nexport interface IBoxAndWhiskerProps extends IStatsBaseProps {\n  q1: number;\n  q3: number;\n  median: number;\n  whiskerMin: number;\n  whiskerMax: number;\n  mean: number;\n}\n\nexport class BoxAndWiskers extends StatsBase<IBoxAndWhiskerProps, IBoxAndWhiskersOptions> {\n  /**\n   * @hidden\n   */\n  draw(ctx: CanvasRenderingContext2D): void {\n    ctx.save();\n\n    ctx.fillStyle = this.options.backgroundColor;\n    ctx.strokeStyle = this.options.borderColor;\n    ctx.lineWidth = this.options.borderWidth;\n\n    this._drawBoxPlot(ctx);\n    this._drawOutliers(ctx);\n    this._drawMeanDot(ctx);\n\n    ctx.restore();\n\n    this._drawItems(ctx);\n  }\n\n  /**\n   * @hidden\n   */\n  protected _drawBoxPlot(ctx: CanvasRenderingContext2D): void {\n    if (this.isVertical()) {\n      this._drawBoxPlotVertical(ctx);\n    } else {\n      this._drawBoxPlotHorizontal(ctx);\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  protected _drawBoxPlotVertical(ctx: CanvasRenderingContext2D): void {\n    const { options } = this;\n    const props = this.getProps(['x', 'width', 'q1', 'q3', 'median', 'whiskerMin', 'whiskerMax']);\n\n    const { x } = props;\n    const { width } = props;\n    const x0 = x - width / 2;\n    // Draw the q1>q3 box\n    if (props.q3 > props.q1) {\n      ctx.fillRect(x0, props.q1, width, props.q3 - props.q1);\n    } else {\n      ctx.fillRect(x0, props.q3, width, props.q1 - props.q3);\n    }\n\n    // Draw the median line\n    ctx.save();\n    if (options.medianColor && options.medianColor !== 'transparent' && options.medianColor !== '#0000') {\n      ctx.strokeStyle = options.medianColor;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x0, props.median);\n    ctx.lineTo(x0 + width, props.median);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n\n    ctx.save();\n    // fill the part below the median with lowerColor\n    if (\n      options.lowerBackgroundColor &&\n      options.lowerBackgroundColor !== 'transparent' &&\n      options.lowerBackgroundColor !== '#0000'\n    ) {\n      ctx.fillStyle = options.lowerBackgroundColor;\n      if (props.q3 > props.q1) {\n        ctx.fillRect(x0, props.median, width, props.q3 - props.median);\n      } else {\n        ctx.fillRect(x0, props.median, width, props.q1 - props.median);\n      }\n    }\n    ctx.restore();\n\n    // Draw the border around the main q1>q3 box\n    if (props.q3 > props.q1) {\n      ctx.strokeRect(x0, props.q1, width, props.q3 - props.q1);\n    } else {\n      ctx.strokeRect(x0, props.q3, width, props.q1 - props.q3);\n    }\n\n    // Draw the whiskers\n    ctx.beginPath();\n    ctx.moveTo(x0, props.whiskerMin);\n    ctx.lineTo(x0 + width, props.whiskerMin);\n    ctx.moveTo(x, props.whiskerMin);\n    ctx.lineTo(x, props.q1);\n    ctx.moveTo(x0, props.whiskerMax);\n    ctx.lineTo(x0 + width, props.whiskerMax);\n    ctx.moveTo(x, props.whiskerMax);\n    ctx.lineTo(x, props.q3);\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  /**\n   * @hidden\n   */\n  protected _drawBoxPlotHorizontal(ctx: CanvasRenderingContext2D): void {\n    const { options } = this;\n    const props = this.getProps(['y', 'height', 'q1', 'q3', 'median', 'whiskerMin', 'whiskerMax']);\n\n    const { y } = props;\n    const { height } = props;\n    const y0 = y - height / 2;\n\n    // Draw the q1>q3 box\n    if (props.q3 > props.q1) {\n      ctx.fillRect(props.q1, y0, props.q3 - props.q1, height);\n    } else {\n      ctx.fillRect(props.q3, y0, props.q1 - props.q3, height);\n    }\n\n    // Draw the median line\n    ctx.save();\n    if (options.medianColor && options.medianColor !== 'transparent') {\n      ctx.strokeStyle = options.medianColor;\n    }\n    ctx.beginPath();\n    ctx.moveTo(props.median, y0);\n    ctx.lineTo(props.median, y0 + height);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n\n    ctx.save();\n    // fill the part below the median with lowerColor\n    if (options.lowerBackgroundColor && options.lowerBackgroundColor !== 'transparent') {\n      ctx.fillStyle = options.lowerBackgroundColor;\n      if (props.q3 > props.q1) {\n        ctx.fillRect(props.median, y0, props.q3 - props.median, height);\n      } else {\n        ctx.fillRect(props.median, y0, props.q1 - props.median, height);\n      }\n    }\n    ctx.restore();\n\n    // Draw the border around the main q1>q3 box\n    if (props.q3 > props.q1) {\n      ctx.strokeRect(props.q1, y0, props.q3 - props.q1, height);\n    } else {\n      ctx.strokeRect(props.q3, y0, props.q1 - props.q3, height);\n    }\n\n    // Draw the whiskers\n    ctx.beginPath();\n    ctx.moveTo(props.whiskerMin, y0);\n    ctx.lineTo(props.whiskerMin, y0 + height);\n    ctx.moveTo(props.whiskerMin, y);\n    ctx.lineTo(props.q1, y);\n    ctx.moveTo(props.whiskerMax, y0);\n    ctx.lineTo(props.whiskerMax, y0 + height);\n    ctx.moveTo(props.whiskerMax, y);\n    ctx.lineTo(props.q3, y);\n    ctx.closePath();\n    ctx.stroke();\n  }\n\n  /**\n   * @hidden\n   */\n  _getBounds(useFinalPosition?: boolean): { left: number; top: number; right: number; bottom: number } {\n    const vert = this.isVertical();\n    if (this.x == null) {\n      return {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n      };\n    }\n\n    if (vert) {\n      const { x, width, whiskerMax, whiskerMin } = this.getProps(\n        ['x', 'width', 'whiskerMin', 'whiskerMax'],\n        useFinalPosition\n      );\n      const x0 = x - width / 2;\n      return {\n        left: x0,\n        top: whiskerMax,\n        right: x0 + width,\n        bottom: whiskerMin,\n      };\n    }\n    const { y, height, whiskerMax, whiskerMin } = this.getProps(\n      ['y', 'height', 'whiskerMin', 'whiskerMax'],\n      useFinalPosition\n    );\n    const y0 = y - height / 2;\n    return {\n      left: whiskerMin,\n      top: y0,\n      right: whiskerMax,\n      bottom: y0 + height,\n    };\n  }\n\n  static id = 'boxandwhiskers';\n\n  /**\n   * @hidden\n   */\n  static defaults = /* #__PURE__ */ {\n    ...BarElement.defaults,\n    ...baseDefaults,\n    medianColor: 'transparent',\n    lowerBackgroundColor: 'transparent',\n  };\n\n  /**\n   * @hidden\n   */\n  static defaultRoutes = /* #__PURE__ */ { ...BarElement.defaultRoutes, ...baseRoutes };\n}\n\ndeclare module 'chart.js' {\n  export interface ElementOptionsByType<TType extends ChartType> {\n    boxandwhiskers: ScriptableAndArrayOptions<IBoxAndWhiskersOptions & CommonHoverOptions, ScriptableContext<TType>>;\n  }\n}\n", "import {\n  BarElement,\n  type ChartType,\n  type CommonHoverOptions,\n  type ScriptableAndArrayOptions,\n  type ScriptableContext,\n} from 'chart.js';\nimport { drawPoint } from 'chart.js/helpers';\nimport type { IKDEPoint } from '../data';\nimport { StatsBase, baseDefaults, baseRoutes, type IStatsBaseOptions, type IStatsBaseProps } from './base';\n\nexport type IViolinElementOptions = IStatsBaseOptions;\n\nexport interface IViolinElementProps extends IStatsBaseProps {\n  min: number;\n  max: number;\n  median: number;\n  coords: IKDEPoint[];\n  maxEstimate?: number;\n}\n\nexport class Violin extends StatsBase<IViolinElementProps, IViolinElementOptions> {\n  /**\n   * @hidden\n   */\n  draw(ctx: CanvasRenderingContext2D): void {\n    ctx.save();\n\n    ctx.fillStyle = this.options.backgroundColor;\n    ctx.strokeStyle = this.options.borderColor;\n    ctx.lineWidth = this.options.borderWidth;\n\n    const props = this.getProps(['x', 'y', 'median', 'width', 'height', 'min', 'max', 'coords', 'maxEstimate']);\n\n    if (props.median != null) {\n      // draw median dot\n      drawPoint(\n        ctx,\n        {\n          pointStyle: 'rectRot',\n          radius: 5,\n          borderWidth: this.options.borderWidth,\n        },\n        props.x,\n        props.y\n      );\n    }\n\n    if (props.coords && props.coords.length > 0) {\n      this._drawCoords(ctx, props);\n    }\n    this._drawOutliers(ctx);\n    this._drawMeanDot(ctx);\n\n    ctx.restore();\n\n    this._drawItems(ctx);\n  }\n\n  /**\n   * @hidden\n   */\n  protected _drawCoords(\n    ctx: CanvasRenderingContext2D,\n    props: Pick<IViolinElementProps, 'x' | 'coords' | 'y' | 'maxEstimate' | 'width' | 'height' | 'min' | 'max'>\n  ): void {\n    let maxEstimate: number;\n    if (props.maxEstimate == null) {\n      maxEstimate = props.coords.reduce((a, d) => Math.max(a, d.estimate), Number.NEGATIVE_INFINITY);\n    } else {\n      maxEstimate = props.maxEstimate;\n    }\n\n    ctx.beginPath();\n    if (this.isVertical()) {\n      const { x, width } = props;\n      const factor = width / 2 / maxEstimate;\n\n      props.coords.forEach((c) => {\n        ctx.lineTo(x - c.estimate * factor, c.v);\n      });\n\n      props.coords\n        .slice()\n        .reverse()\n        .forEach((c) => {\n          ctx.lineTo(x + c.estimate * factor, c.v);\n        });\n    } else {\n      const { y, height } = props;\n      const factor = height / 2 / maxEstimate;\n\n      props.coords.forEach((c) => {\n        ctx.lineTo(c.v, y - c.estimate * factor);\n      });\n\n      props.coords\n        .slice()\n        .reverse()\n        .forEach((c) => {\n          ctx.lineTo(c.v, y + c.estimate * factor);\n        });\n    }\n    ctx.closePath();\n    ctx.stroke();\n    ctx.fill();\n  }\n\n  /**\n   * @hidden\n   */\n  _getBounds(useFinalPosition?: boolean): { left: number; top: number; right: number; bottom: number } {\n    if (this.isVertical()) {\n      const { x, width, min, max } = this.getProps(['x', 'width', 'min', 'max'], useFinalPosition);\n      const x0 = x - width / 2;\n      return {\n        left: x0,\n        top: max,\n        right: x0 + width,\n        bottom: min,\n      };\n    }\n    const { y, height, min, max } = this.getProps(['y', 'height', 'min', 'max'], useFinalPosition);\n    const y0 = y - height / 2;\n    return {\n      left: min,\n      top: y0,\n      right: max,\n      bottom: y0 + height,\n    };\n  }\n\n  static id = 'violin';\n\n  /**\n   * @hidden\n   */\n  static defaults = /* #__PURE__ */ { ...BarElement.defaults, ...baseDefaults };\n\n  /**\n   * @hidden\n   */\n  static defaultRoutes = /* #__PURE__ */ { ...BarElement.defaultRoutes, ...baseRoutes };\n}\n\ndeclare module 'chart.js' {\n  export interface ElementOptionsByType<TType extends ChartType> {\n    violin: ScriptableAndArrayOptions<IViolinElementOptions & CommonHoverOptions, ScriptableContext<TType>>;\n  }\n}\n", "import type { IKDEPoint } from './data';\n\nconst interpolators = {\n  number(from: number | undefined | null, to: number | undefined | null, factor: number) {\n    if (from === to) {\n      return to;\n    }\n    if (from == null) {\n      return to;\n    }\n    if (to == null) {\n      return from;\n    }\n    return from + (to - from) * factor;\n  },\n};\n\nexport function interpolateNumberArray(\n  from: number | number[],\n  to: number | number[],\n  factor: number\n): number | null | undefined | (number | null | undefined)[] {\n  if (typeof from === 'number' && typeof to === 'number') {\n    return interpolators.number(from, to, factor);\n  }\n  if (Array.isArray(from) && Array.isArray(to)) {\n    return to.map((t, i) => interpolators.number(from[i], t, factor));\n  }\n  return to;\n}\n\nexport function interpolateKdeCoords(\n  from: IKDEPoint[],\n  to: IKDEPoint[],\n  factor: number\n): { v: number | null | undefined; estimate: number | null | undefined }[] {\n  if (Array.isArray(from) && Array.isArray(to)) {\n    return to.map((t, i) => ({\n      v: interpolators.number(from[i] ? from[i].v : null, t.v, factor),\n      estimate: interpolators.number(from[i] ? from[i].estimate : null, t.estimate, factor),\n    }));\n  }\n  return to;\n}\n", "import { InteractionItem, TooltipItem, Tooltip, TooltipModel } from 'chart.js';\n\nexport interface ExtendedTooltip extends TooltipModel<'boxplot' | 'violin'> {\n  _tooltipOutlier?: {\n    index: number;\n    datasetIndex: number;\n  };\n  _tooltipItem?: {\n    index: number;\n    datasetIndex: number;\n  };\n}\n\n/**\n * @hidden\n */\nexport function patchInHoveredOutlier(\n  this: TooltipModel<'boxplot' | 'violin'>,\n  item: TooltipItem<'boxplot' | 'violin'>\n): void {\n  const value = item.formattedValue as any;\n  const that = this as ExtendedTooltip;\n  if (value && that._tooltipOutlier != null && item.datasetIndex === that._tooltipOutlier.datasetIndex) {\n    value.hoveredOutlierIndex = that._tooltipOutlier.index;\n  }\n  if (value && that._tooltipItem != null && item.datasetIndex === that._tooltipItem.datasetIndex) {\n    value.hoveredItemIndex = that._tooltipItem.index;\n  }\n}\n\n/**\n * based on average positioner but allow access to the tooltip instance\n * @hidden\n */\nexport function outlierPositioner(\n  this: TooltipModel<'boxplot' | 'violin'>,\n  items: readonly InteractionItem[],\n  eventPosition: { x: number; y: number }\n): false | { x: number; y: number } {\n  if (!items.length) {\n    return false;\n  }\n  let x = 0;\n  let y = 0;\n  let count = 0;\n  for (let i = 0; i < items.length; i += 1) {\n    const el = items[i].element;\n    if (el && el.hasValue()) {\n      const pos = (el as any).tooltipPosition(eventPosition, this);\n      x += pos.x;\n      y += pos.y;\n      count += 1;\n    }\n  }\n  return {\n    x: x / count,\n    y: y / count,\n  };\n}\n\noutlierPositioner.id = 'average';\noutlierPositioner.register = () => {\n  Tooltip.positioners.average = outlierPositioner as any;\n  return outlierPositioner;\n};\n", "import { BarController, Element, ChartMeta, LinearScale, Scale, UpdateMode } from 'chart.js';\nimport { formatNumber } from 'chart.js/helpers';\nimport { interpolateNumberArray } from '../animation';\nimport { outlierPositioner, patchInHoveredOutlier } from '../tooltip';\nimport { defaultStatsOptions, IBaseOptions, IBaseStats } from '../data';\n/**\n * @hidden\n */\nexport /* #__PURE__ */ function baseDefaults(keys: string[]): Record<string, unknown> {\n  const colorKeys = ['borderColor', 'backgroundColor'].concat(keys.filter((c) => c.endsWith('Color')));\n  return {\n    animations: {\n      numberArray: {\n        fn: interpolateNumberArray,\n        properties: ['outliers', 'items'],\n      },\n      colors: {\n        type: 'color',\n        properties: colorKeys,\n      },\n    },\n    transitions: {\n      show: {\n        animations: {\n          colors: {\n            type: 'color',\n            properties: colorKeys,\n            from: 'transparent',\n          },\n        },\n      },\n      hide: {\n        animations: {\n          colors: {\n            type: 'color',\n            properties: colorKeys,\n            to: 'transparent',\n          },\n        },\n      },\n    },\n    minStats: 'min',\n    maxStats: 'max',\n    ...defaultStatsOptions,\n  };\n}\n\nexport function defaultOverrides(): Record<string, unknown> {\n  return {\n    plugins: {\n      tooltip: {\n        position: outlierPositioner.register().id,\n        callbacks: {\n          beforeLabel: patchInHoveredOutlier,\n        },\n      },\n    },\n  };\n}\n\nexport abstract class StatsBase<S extends IBaseStats, C extends Required<IBaseOptions>> extends BarController {\n  /**\n   * @hidden\n   */\n  declare options: C;\n\n  /**\n   * @hidden\n   */\n\n  protected _transformStats<T>(target: any, source: S, mapper: (v: number) => T): void {\n    for (const key of ['min', 'max', 'median', 'q3', 'q1', 'mean']) {\n      const v = source[key as keyof IBaseStats];\n      if (typeof v === 'number') {\n        target[key] = mapper(v);\n      }\n    }\n    for (const key of ['outliers', 'items']) {\n      if (Array.isArray(source[key as keyof IBaseStats])) {\n        target[key] = source[key as 'outliers' | 'items'].map(mapper);\n      }\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  getMinMax(scale: Scale, canStack?: boolean | undefined): { min: number; max: number } {\n    const bak = scale.axis;\n    const config = this.options;\n\n    scale.axis = config.minStats;\n    const { min } = super.getMinMax(scale, canStack);\n\n    scale.axis = config.maxStats;\n    const { max } = super.getMinMax(scale, canStack);\n\n    scale.axis = bak;\n    return { min, max };\n  }\n\n  /**\n   * @hidden\n   */\n  parsePrimitiveData(meta: ChartMeta, data: any[], start: number, count: number): Record<string, unknown>[] {\n    const vScale = meta.vScale!;\n\n    const iScale = meta.iScale!;\n    const labels = iScale.getLabels();\n    const r = [];\n    for (let i = 0; i < count; i += 1) {\n      const index = i + start;\n      const parsed: any = {};\n      parsed[iScale.axis] = iScale.parse(labels[index], index);\n      const stats = this._parseStats(data == null ? null : data[index], this.options);\n      if (stats) {\n        Object.assign(parsed, stats);\n        parsed[vScale.axis] = stats.median;\n      }\n      r.push(parsed);\n    }\n    return r;\n  }\n\n  /**\n   * @hidden\n   */\n  parseArrayData(meta: ChartMeta, data: any[], start: number, count: number): Record<string, unknown>[] {\n    return this.parsePrimitiveData(meta, data, start, count);\n  }\n\n  /**\n   * @hidden\n   */\n  parseObjectData(meta: ChartMeta, data: any[], start: number, count: number): Record<string, unknown>[] {\n    return this.parsePrimitiveData(meta, data, start, count);\n  }\n\n  /**\n   * @hidden\n   */\n\n  protected abstract _parseStats(value: any, options: C): S | undefined;\n  /**\n   * @hidden\n   */\n  getLabelAndValue(index: number): {\n    label: string;\n    value: string & { raw: S; hoveredOutlierIndex: number; hoveredItemIndex: number } & S;\n  } {\n    const r = super.getLabelAndValue(index) as any;\n    const { vScale } = this._cachedMeta;\n    const parsed = this.getParsed(index) as unknown as S;\n    if (!vScale || !parsed || r.value === 'NaN') {\n      return r;\n    }\n    r.value = {\n      raw: parsed,\n      hoveredOutlierIndex: -1,\n      hoveredItemIndex: -1,\n    };\n    this._transformStats(r.value, parsed, (v) => vScale.getLabelForValue(v));\n    const s = this._toStringStats(r.value.raw);\n    r.value.toString = function toString() {\n      // custom to string function for the 'value'\n      if (this.hoveredOutlierIndex >= 0) {\n        // TODO formatter\n        return `(outlier: ${this.outliers[this.hoveredOutlierIndex]})`;\n      }\n      if (this.hoveredItemIndex >= 0) {\n        // TODO formatter\n        return `(item: ${this.items[this.hoveredItemIndex]})`;\n      }\n      return s;\n    };\n    return r;\n  }\n\n  /**\n   * @hidden\n   */\n\n  protected _toStringStats(b: S): string {\n    const f = (v: number) => (v == null ? 'NaN' : formatNumber(v, this.chart.options.locale!, {}));\n    return `(min: ${f(b.min)}, 25% quantile: ${f(b.q1)}, median: ${f(b.median)}, mean: ${f(b.mean)}, 75% quantile: ${f(\n      b.q3\n    )}, max: ${f(b.max)})`;\n  }\n\n  /**\n   * @hidden\n   */\n\n  updateElement(rectangle: Element, index: number, properties: any, mode: UpdateMode): void {\n    const reset = mode === 'reset';\n    const scale = this._cachedMeta.vScale as LinearScale;\n    const parsed = this.getParsed(index) as unknown as S;\n    const base = scale.getBasePixel();\n\n    properties._datasetIndex = this.index;\n\n    properties._index = index;\n    this._transformStats(properties, parsed, (v) => (reset ? base : scale.getPixelForValue(v, index)));\n    super.updateElement(rectangle, index, properties, mode);\n  }\n}\n", "import { registry, DatasetControllerChartComponent, ChartComponent } from 'chart.js';\n\nexport default function patchController<T, TYPE>(\n  type: TYPE,\n  config: T,\n  controller: DatasetControllerChartComponent,\n  elements: ChartComponent | ChartComponent[] = [],\n  scales: ChartComponent | ChartComponent[] = []\n): T & { type: TYPE } {\n  registry.addControllers(controller);\n  if (Array.isArray(elements)) {\n    registry.addElements(...elements);\n  } else {\n    registry.addElements(elements);\n  }\n  if (Array.isArray(scales)) {\n    registry.addScales(...scales);\n  } else {\n    registry.addScales(scales);\n  }\n  const c = config as any;\n  c.type = type;\n  return c;\n}\n", "import {\n  Chart,\n  BarController,\n  ControllerDatasetOptions,\n  ScriptableAndArrayOptions,\n  CommonHoverOptions,\n  ChartItem,\n  ChartConfiguration,\n  LinearScale,\n  CategoryScale,\n  AnimationOptions,\n  ScriptableContext,\n  CartesianScaleTypeRegistry,\n  BarControllerDatasetOptions,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport { asBoxPlotStats, IBoxPlot, IBoxplotOptions } from '../data';\nimport { baseDefaults, StatsBase, defaultOverrides } from './StatsBase';\nimport { BoxAndWiskers, IBoxAndWhiskersOptions } from '../elements';\nimport patchController from './patchController';\nimport { boxOptionsKeys } from '../elements/BoxAndWiskers';\n\nexport class BoxPlotController extends StatsBase<IBoxPlot, Required<IBoxplotOptions>> {\n  /**\n   * @hidden\n   */\n\n  protected _parseStats(value: unknown, config: IBoxplotOptions): IBoxPlot | undefined {\n    return asBoxPlotStats(value, config);\n  }\n\n  /**\n   * @hidden\n   */\n\n  protected _transformStats<T>(target: any, source: IBoxPlot, mapper: (v: number) => T): void {\n    super._transformStats(target, source, mapper);\n    for (const key of ['whiskerMin', 'whiskerMax']) {\n      target[key] = mapper(source[key as 'whiskerMin' | 'whiskerMax']);\n    }\n  }\n\n  static readonly id = 'boxplot';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    BarController.defaults,\n    baseDefaults(boxOptionsKeys),\n    {\n      animations: {\n        numbers: {\n          type: 'number',\n          properties: (BarController.defaults as any).animations.numbers.properties.concat(\n            ['q1', 'q3', 'min', 'max', 'median', 'whiskerMin', 'whiskerMax', 'mean'],\n            boxOptionsKeys.filter((c) => !c.endsWith('Color'))\n          ),\n        },\n      },\n      dataElementType: BoxAndWiskers.id,\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [(BarController as any).overrides, defaultOverrides()]);\n}\n\nexport interface BoxPlotControllerDatasetOptions\n  extends ControllerDatasetOptions,\n    Pick<\n      BarControllerDatasetOptions,\n      'barPercentage' | 'barThickness' | 'categoryPercentage' | 'maxBarThickness' | 'minBarLength'\n    >,\n    IBoxplotOptions,\n    ScriptableAndArrayOptions<IBoxAndWhiskersOptions, ScriptableContext<'boxplot'>>,\n    ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'boxplot'>>,\n    AnimationOptions<'boxplot'> {}\n\nexport type BoxPlotDataPoint = number[] | (Partial<IBoxPlot> & Pick<IBoxPlot, 'min' | 'max' | 'median' | 'q1' | 'q3'>);\n\nexport type IBoxPlotChartOptions = IBoxplotOptions;\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    boxplot: {\n      chartOptions: IBoxPlotChartOptions;\n      datasetOptions: BoxPlotControllerDatasetOptions;\n      defaultDataPoint: BoxPlotDataPoint;\n      scales: keyof CartesianScaleTypeRegistry;\n      metaExtensions: object;\n      parsedDataType: IBoxPlot & ChartTypeRegistry['bar']['parsedDataType'];\n    };\n  }\n}\n\nexport class BoxPlotChart<DATA extends unknown[] = BoxPlotDataPoint[], LABEL = string> extends Chart<\n  'boxplot',\n  DATA,\n  LABEL\n> {\n  static id = BoxPlotController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'boxplot', DATA, LABEL>, 'type'>) {\n    super(item, patchController('boxplot', config, BoxPlotController, BoxAndWiskers, [LinearScale, CategoryScale]));\n  }\n}\n", "import {\n  Chart,\n  BarController,\n  ChartItem,\n  ControllerDatasetOptions,\n  ScriptableAndArrayOptions,\n  CommonHoverOptions,\n  ChartConfiguration,\n  LinearScale,\n  CategoryScale,\n  AnimationOptions,\n  ScriptableContext,\n  CartesianScaleTypeRegistry,\n  BarControllerDatasetOptions,\n} from 'chart.js';\nimport { merge } from 'chart.js/helpers';\nimport { asViolinStats, IViolin, IViolinOptions } from '../data';\nimport { StatsBase, baseDefaults, defaultOverrides } from './StatsBase';\nimport { baseOptionKeys } from '../elements/base';\nimport { IViolinElementOptions, Violin } from '../elements';\nimport { interpolateKdeCoords } from '../animation';\nimport patchController from './patchController';\n\nexport class ViolinController extends StatsBase<IViolin, Required<IViolinOptions>> {\n  /**\n   * @hidden\n   */\n\n  protected _parseStats(value: any, config: IViolinOptions): IViolin | undefined {\n    return asViolinStats(value, config);\n  }\n\n  /**\n   * @hidden\n   */\n\n  protected _transformStats<T>(target: any, source: IViolin, mapper: (v: number) => T): void {\n    super._transformStats(target, source, mapper);\n\n    target.maxEstimate = source.maxEstimate;\n    if (Array.isArray(source.coords)) {\n      target.coords = source.coords.map((c) => ({ ...c, v: mapper(c.v) }));\n    }\n  }\n\n  static readonly id = 'violin';\n\n  /**\n   * @hidden\n   */\n  static readonly defaults: any = /* #__PURE__ */ merge({}, [\n    BarController.defaults,\n    baseDefaults(baseOptionKeys),\n    {\n      points: 100,\n      animations: {\n        numbers: {\n          type: 'number',\n          properties: (BarController.defaults as any).animations.numbers.properties.concat(\n            ['q1', 'q3', 'min', 'max', 'median', 'maxEstimate'],\n            baseOptionKeys.filter((c) => !c.endsWith('Color'))\n          ),\n        },\n        kdeCoords: {\n          fn: interpolateKdeCoords,\n          properties: ['coords'],\n        },\n      },\n      dataElementType: Violin.id,\n    },\n  ]);\n\n  /**\n   * @hidden\n   */\n  static readonly overrides: any = /* #__PURE__ */ merge({}, [(BarController as any).overrides, defaultOverrides()]);\n}\nexport type ViolinDataPoint = number[] | (Partial<IViolin> & Pick<IViolin, 'median' | 'coords'>);\n\nexport interface ViolinControllerDatasetOptions\n  extends ControllerDatasetOptions,\n    Pick<\n      BarControllerDatasetOptions,\n      'barPercentage' | 'barThickness' | 'categoryPercentage' | 'maxBarThickness' | 'minBarLength'\n    >,\n    IViolinOptions,\n    ScriptableAndArrayOptions<IViolinElementOptions, ScriptableContext<'violin'>>,\n    ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'violin'>>,\n    AnimationOptions<'violin'> {}\n\nexport type IViolinChartOptions = IViolinOptions;\n\ndeclare module 'chart.js' {\n  export interface ChartTypeRegistry {\n    violin: {\n      chartOptions: IViolinChartOptions;\n      datasetOptions: ViolinControllerDatasetOptions;\n      defaultDataPoint: ViolinDataPoint;\n      scales: keyof CartesianScaleTypeRegistry;\n      metaExtensions: object;\n      parsedDataType: IViolin & ChartTypeRegistry['bar']['parsedDataType'];\n    };\n  }\n}\n\nexport class ViolinChart<DATA extends unknown[] = ViolinDataPoint[], LABEL = string> extends Chart<\n  'violin',\n  DATA,\n  LABEL\n> {\n  static id = ViolinController.id;\n\n  constructor(item: ChartItem, config: Omit<ChartConfiguration<'violin', DATA, LABEL>, 'type'>) {\n    super(item, patchController('violin', config, ViolinController, Violin, [LinearScale, CategoryScale]));\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAAA,IAAM,SAAS,KAAK,KAAK,IAAI,KAAK,EAAE;AAGpC,SAAS,SAAS,GAAS;AACzB,SAAO,KAAK,IAAI,OAAO,IAAI,CAAC,IAAI;AAClC;AAEA,SAAS,iBAAiB,UAAkB,KAAW;AACrD,SAAQ,WAAW,OAAQ,MAAM;AACnC;AASA,SAAS,IAAI,KAAa,UAAkB,KAAW;AACrD,MAAI,IAAI,KAAK,KAAK,iBAAiB,UAAU,GAAG,CAAC;AACjD,MAAI,OAAO,QAAQ,UAAU;AAC3B,QAAI,KAAK,IAAI,GAAG,MAAM,IAAI;;AAE5B,SAAO,OAAO,IAAI,KAAK,IAAI,KAAK,IAAI;AACtC;AAIwB,SAAA,IAAI,OAI3B;AACC,QAAM,MAAM,MAAM,MAAM;AACxB,QAAM,YAAY,IAAI,MAAM,KAAK,MAAM,UAAU,GAAG;AAEpD,SAAO,CAAC,MAAa;AACnB,QAAI,IAAI;AACR,QAAI,MAAM;AACV,SAAK,IAAI,GAAG,IAAI,KAAK,KAAK;AACxB,YAAM,IAAI,MAAM,MAAM,CAAC;AACvB,aAAO,UAAU,IAAI,KAAK,SAAS;;AAErC,WAAO,MAAM,YAAY;EAC3B;AACF;SClCgB,qBACd,KACA,QACA,aAA+D;AAE/D,QAAM,KAAK,SAAS;AACpB,QAAM,UAAU,CAAC,MAAa;AAC5B,UAAM,QAAQ,IAAI;AAClB,UAAM,KAAK,KAAK,MAAM,KAAK;AAC3B,UAAM,IAAI,QAAQ;AAClB,UAAM,IAAI,IAAI,EAAE;AAEhB,WAAO,MAAM,IAAI,IAAI,YAAY,GAAG,IAAI,KAAK,IAAI,KAAK,GAAG,EAAE,CAAC,GAAG,CAAC;EAClE;AAEA,SAAO;IACL,IAAI,QAAQ,IAAI;IAChB,QAAQ,QAAQ,GAAG;IACnB,IAAI,QAAQ,IAAI;;AAEpB;AAMM,SAAU,eAAe,KAAwB,SAAS,IAAI,QAAM;AACxE,SAAO,qBAAqB,KAAK,QAAQ,CAAC,GAAG,GAAG,UAAU,IAAI,SAAS,IAAI,EAAE;AAC/E;AAMM,SAAU,gBAAgB,KAAwB,SAAS,IAAI,QAAM;AACzE,SAAO,qBAAqB,KAAK,QAAQ,CAAC,GAAG,GAAG,aAAa,KAAK,IAAI,KAAK,QAAQ;AACrF;AAKM,SAAU,eAAe,KAAwB,SAAS,IAAI,QAAM;AACxE,SAAO,qBAAqB,KAAK,QAAQ,CAAC,MAAM,CAAC;AACnD;AAKM,SAAU,gBAAgB,KAAwB,SAAS,IAAI,QAAM;AACzE,SAAO,qBAAqB,KAAK,QAAQ,CAAC,GAAG,MAAM,CAAC;AACtD;AAKM,SAAU,iBAAiB,KAAwB,SAAS,IAAI,QAAM;AAC1E,SAAO,qBAAqB,KAAK,QAAQ,CAAC,GAAG,GAAG,aAAc,WAAW,MAAM,IAAI,CAAE;AACvF;AAKM,SAAU,kBAAkB,KAAwB,SAAS,IAAI,QAAM;AAC3E,SAAO,qBAAqB,KAAK,QAAQ,CAAC,GAAG,OAAO,IAAI,KAAK,GAAG;AAClE;AASM,SAAU,iBAAiB,KAAwB,SAAS,IAAI,QAAM;AAE1E,QAAM,IAAI;AAGV,QAAM,KAAK,KAAK,OAAO,IAAI,KAAK,CAAC,IAAI;AACrC,QAAM,UAAU,CAAC,MAAc,OAAO,IAAI,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC;AAEnF,SAAO;IACL,IAAI,QAAQ,EAAE;IACd,QAAQ,SAAS,IAAI,KAAK,CAAC;IAC3B,IAAI,QAAQ,IAAI,IAAI,EAAE;;AAE1B;AAOM,SAAU,gBAAgB,KAAwB,SAAS,IAAI,QAAM;AACzE,SAAO,iBAAiB,KAAK,MAAM;AACrC;ACGA,SAAS,iBAAiB,MAAqD;AAC7E,MAAI,QAAQ;AACZ,QAAM,EAAE,OAAM,IAAK;AAEnB,QAAM,KAAK,gBAAgB,eAAe,IAAI,aAAa,MAAM,IAAI,IAAI,aAAa,MAAM;AAE5F,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAClC,UAAM,IAAI,KAAK,CAAC;AAChB,QAAI,KAAK,QAAQ,OAAO,MAAM,CAAC,GAAG;AAChC;;AAEF,OAAG,KAAK,IAAI;AACZ,aAAS;;AAGX,QAAM,UAAU,SAAS;AAEzB,MAAI,UAAU,GAAG;AACf,WAAO;MACL,KAAK,OAAO;MACZ,KAAK,OAAO;MACZ;MACA,GAAG,CAAA;;;AAKP,QAAM,YAAY,UAAU,SAAS,KAAK,GAAG,SAAS,GAAG,KAAK;AAG9D,YAAU,KAAK,CAAC,GAAG,MAAO,MAAM,IAAI,IAAI,IAAI,IAAI,KAAK,CAAE;AAGvD,QAAM,MAAM,UAAU,CAAC;AACvB,QAAM,MAAM,UAAU,UAAU,SAAS,CAAC;AAE1C,SAAO;IACL;IACA;IACA;IACA,GAAG;;AAEP;AAEA,SAAS,eAAe,MAAqD;AAC3E,MAAI,KAAK,WAAW,GAAG;AACrB,WAAO;MACL,KAAK,OAAO;MACZ,KAAK,OAAO;MACZ,SAAS;MACT,GAAG,CAAA;;;AAGP,QAAM,MAAM,KAAK,CAAC;AAClB,QAAM,MAAM,KAAK,KAAK,SAAS,CAAC;AAEhC,SAAO;IACL;IACA;IACA,SAAS;IACT,GAAG;;AAEP;AAEA,SAAS,gBACP,GACA,OACA,KACA,KACA,EAAE,KAAK,WAAW,MAAM,aAAY,GAAiC;AAErE,QAAM,OAAO,CAAC,GAAW,MAAc,KAAK,IAAI,IAAI,CAAC,IAAI;AAEzD,QAAM,EAAE,QAAQ,IAAI,GAAE,IAAK,UAAU,GAAG,KAAK;AAC7C,QAAM,MAAM,KAAK;AACjB,QAAM,cAAc,OAAO,SAAS,YAAY,OAAO;AAEvD,MAAI,aAAa,cAAc,KAAK,IAAI,KAAK,KAAK,OAAO,GAAG,IAAI;AAChE,MAAI,cAAc,cAAc,KAAK,IAAI,KAAK,KAAK,OAAO,GAAG,IAAI;AAEjE,QAAM,aAAuB,CAAA;AAE7B,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK,GAAG;AACjC,UAAM,IAAI,EAAE,CAAC;AACb,QAAI,KAAK,cAAc,KAAK,GAAG,UAAU,GAAG;AAC1C,UAAI,iBAAiB,WAAW;AAC9B,qBAAa;;AAEf;;AAGF,QAAI,WAAW,WAAW,KAAK,CAAC,KAAK,WAAW,WAAW,SAAS,CAAC,GAAG,CAAC,GAAG;AAC1E,iBAAW,KAAK,CAAC;;;AAIrB,QAAM,sBAAgC,CAAA;AACtC,WAAS,IAAI,QAAQ,GAAG,KAAK,GAAG,KAAK,GAAG;AACtC,UAAM,IAAI,EAAE,CAAC;AACb,QAAI,KAAK,eAAe,KAAK,GAAG,WAAW,GAAG;AAC5C,UAAI,iBAAiB,WAAW;AAC9B,sBAAc;;AAEhB;;AAGF,SACG,oBAAoB,WAAW,KAAK,CAAC,KAAK,oBAAoB,oBAAoB,SAAS,CAAC,GAAG,CAAC,OAChG,WAAW,WAAW,KAAK,CAAC,KAAK,WAAW,WAAW,SAAS,CAAC,GAAG,CAAC,IACtE;AACA,0BAAoB,KAAK,CAAC;;;AAG9B,QAAM,UAAU,WAAW,OAAO,oBAAoB,QAAO,CAAE;AAE/D,SAAO;IACL;IACA;IACA;IACA;IACA;IACA;IACA;;AAEJ;AAEA,SAAS,aAAa,GAAsB,OAAa;AACvD,MAAI,OAAO;AAEX,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,UAAM,IAAI,EAAE,CAAC;AACb,YAAQ;;AAEV,UAAQ;AAER,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC9B,UAAM,IAAI,EAAE,CAAC;AACb,iBAAa,IAAI,SAAS,IAAI;;AAEhC,cAAY;AAEZ,SAAO;IACL;IACA;;AAEJ;AAEwB,SAAA,QACtB,MACA,UAA+B,CAAA,GAAE;AAEjC,QAAM,cAA6C;IACjD,MAAM;IACN,KAAK;IACL,WAAW;IACX,gBAAgB;IAChB,cAAc;IACd,GAAG;;AAGL,QAAM,EAAE,SAAS,GAAG,KAAK,IAAG,IAAK,YAAY,iBAAiB,eAAe,IAAI,IAAI,iBAAiB,IAAI;AAE1G,QAAM,UAAoB;IACxB,KAAK,OAAO;IACZ,KAAK,OAAO;IACZ,MAAM,OAAO;IACb;IACA,KAAK,OAAO;IACZ,OAAO,KAAK;IACZ,aAAa,OAAO;IACpB,YAAY,OAAO;IACnB,SAAS,CAAA;IACT,QAAQ,OAAO;IACf,IAAI,OAAO;IACX,IAAI,OAAO;IACX,UAAU;IACV,OAAO,CAAA;IACP,KAAK,MAAM;;AAEb,QAAM,QAAQ,KAAK,SAAS;AAE5B,MAAI,UAAU,GAAG;AACf,WAAO;;AAET,QAAM,SAAgC;IACpC;IACA;IACA,OAAO,KAAK;IACZ;IACA,OAAO;IACP,GAAG,aAAa,GAAG,KAAK;IACxB,GAAG,gBAAgB,GAAG,OAAO,KAAK,KAAK,WAAW;;AAEpD,SAAO;IACL,GAAG;IACH,KAAK,IAAI,MAAM;;AAEnB;;;AC5PM,SAAU,SACdA,UACA,KACA,OAAO,KAAG;AAEV,QAAM,MAAMA,SAAQ,KAAKA,SAAQ;AAEjC,QAAM,YAAY,OAAO,SAAS,YAAY,OAAO;AACrD,MAAI,aAAa,YAAY,KAAK,IAAIA,SAAQ,KAAKA,SAAQ,KAAK,OAAO,GAAG,IAAIA,SAAQ;AACtF,MAAI,aAAa,YAAY,KAAK,IAAIA,SAAQ,KAAKA,SAAQ,KAAK,OAAO,GAAG,IAAIA,SAAQ;AAEtF,MAAI,MAAM,QAAQ,GAAG,GAAG;AAEtB,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,GAAG;AACtC,YAAM,IAAI,IAAI,CAAC;AACf,UAAI,KAAK,YAAY;AACnB,qBAAa;AACb;;;AAGJ,aAAS,IAAI,IAAI,SAAS,GAAG,KAAK,GAAG,KAAK,GAAG;AAC3C,YAAM,IAAI,IAAI,CAAC;AACf,UAAI,KAAK,YAAY;AACnB,qBAAa;AACb;;;;AAKN,SAAO;IACL;IACA;;AAEJ;AAyEO,IAAM,sBAA6E;EACxF,MAAM;EACN,WAAW;EACX,cAAc;;AAGhB,SAAS,mBAAmB,GAAiB;AAC3C,MAAI,OAAO,MAAM,YAAY;AAC3B,WAAO;;AAET,QAAM,SAAS;IACb,QAAQ;IACR,SAAS;IACT,GAAG;IACH,WAAW;IACX,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,SAAS;IACT,UAAU;;AAEZ,SAAO,OAAO,CAAC,KAAK;AACtB;AAEA,SAAS,sBAAsB,SAAsB;AACnD,QAAM,OAAO,WAAW,QAAQ,OAAO,QAAQ,SAAS,WAAW,oBAAoB,OAAO,QAAQ;AACtG,QAAM,IAAI,WAAW,QAAQ,QAAQ,aAAa,OAAO,iBAAiB,QAAQ;AAClF,QAAM,YAAY,mBAAmB,CAAC;AACtC,QAAM,eACJ,WAAW,QAAQ,OAAO,QAAQ,iBAAiB,WAC/C,oBAAoB,eACpB,QAAQ;AACd,SAAO;IACL;IACA;IACA;;AAEJ;AAKgB,SAAA,aAAa,KAAsD,SAAqB;AACtG,QAAM,KACJ,OAAO,iBAAiB,eAAe,EAAE,eAAe,gBAAgB,eAAe,gBACnF,aAAa,KAAK,GAAG,IACrB;AACN,QAAM,IAAIC,QAAS,IAAI,sBAAsB,OAAO,CAAC;AACrD,SAAO;IACL,OAAO,MAAM,KAAK,EAAE,KAAK;IACzB,UAAU,EAAE;IACZ,YAAY,EAAE;IACd,YAAY,EAAE;IACd,KAAK,EAAE;IACP,QAAQ,EAAE;IACV,MAAM,EAAE;IACR,KAAK,EAAE;IACP,IAAI,EAAE;IACN,IAAI,EAAE;;AAEV;AAEA,SAAS,eAAe,KAAa,KAAa,QAAc;AAE9D,QAAM,QAAQ,MAAM;AACpB,QAAM,UAAoB,CAAA;AAC1B,QAAM,MAAM,QAAQ;AACpB,WAAS,IAAI,KAAK,KAAK,OAAO,MAAM,GAAG,KAAK,KAAK;AAC/C,YAAQ,KAAK,CAAC;;AAEhB,MAAI,QAAQ,QAAQ,SAAS,CAAC,MAAM,KAAK;AACvC,YAAQ,KAAK,GAAG;;AAElB,SAAO;AACT;AAKgB,SAAA,YAAY,KAAwB,SAAuB;AAEzE,MAAI,IAAI,WAAW,GAAG;AACpB,WAAO;;AAET,QAAM,KACJ,OAAO,iBAAiB,eAAe,EAAE,eAAe,gBAAgB,eAAe,gBACnF,aAAa,KAAK,GAAG,IACrB;AACN,QAAM,QAAQA,QAAS,IAAI,sBAAsB,OAAO,CAAC;AAGzD,QAAM,UAAU,eAAe,MAAM,KAAK,MAAM,KAAK,QAAQ,MAAM;AACnE,QAAM,SAAS,QAAQ,IAAI,CAAC,OAAO,EAAE,GAAG,UAAU,MAAM,IAAI,CAAC,EAAC,EAAG;AACjE,QAAM,cAAc,OAAO,OAAO,CAAC,GAAG,MAAM,KAAK,IAAI,GAAG,EAAE,QAAQ,GAAG,OAAO,iBAAiB;AAE7F,SAAO;IACL,KAAK,MAAM;IACX,KAAK,MAAM;IACX,MAAM,MAAM;IACZ,QAAQ,MAAM;IACd,IAAI,MAAM;IACV,IAAI,MAAM;IACV,OAAO,MAAM,KAAK,MAAM,KAAK;IAC7B;IACA,UAAU,CAAA;IACV;;AAEJ;AAKgB,SAAA,eAAe,OAAY,SAAwB;AACjE,MAAI,CAAC,OAAO;AACV,WAAO;;AAET,MAAI,OAAO,MAAM,WAAW,YAAY,OAAO,MAAM,OAAO,YAAY,OAAO,MAAM,OAAO,UAAU;AAEpG,QAAI,OAAO,MAAM,eAAe,aAAa;AAC3C,YAAM,EAAE,KAAI,IAAK,sBAAsB,OAAO;AAC9C,YAAM,EAAE,YAAY,WAAU,IAAK,SACjC,OACA,MAAM,QAAQ,MAAM,KAAK,IAAK,MAAM,MAAmB,MAAK,EAAG,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC,IAAI,MACvF,IAAI;AAEN,YAAM,aAAa;AACnB,YAAM,aAAa;;AAErB,WAAO;;AAET,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAO;;AAET,SAAO,aAAa,OAAO,OAAO;AACpC;AAMgB,SAAA,cAAc,OAAY,SAAuB;AAC/D,MAAI,CAAC,OAAO;AACV,WAAO;;AAET,MAAI,OAAO,MAAM,WAAW,YAAY,MAAM,QAAQ,MAAM,MAAM,GAAG;AACnE,WAAO;;AAET,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAO;;AAET,SAAO,YAAY,OAAO,OAAO;AACnC;AAKM,SAAU,IAAI,OAAO,KAAK,IAAG,GAAE;AAEnC,MAAI,IAAI;AACR,SAAO,MAAK;AACV,SAAK,IAAI,OAAO,SAAS;AACzB,WAAO,IAAI;EACb;AACF;AClIO,IAAMC,iBAAe;EAC1B,aAAa;EAEb,cAAc;EACd,eAAe;EACf,oBAAoB;EAEpB,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,eAAe;EAEf,WAAW;EACX,YAAY;EACZ,iBAAiB;EAEjB,YAAY;EACZ,kBAAkB;;AAMb,IAAM,aAAa;EACxB,wBAAwB;EACxB,oBAAoB;EACpB,qBAAqB;EACrB,iBAAiB;EACjB,qBAAqB;EACrB,iBAAiB;;AAMZ,IAAM,kBAAkC,MAAM,OAAO,KAAKA,cAAY,EAAE,OAAO,OAAO,KAAK,UAAU,CAAC,GAAC;kBAWxG,MAAO,kBAA8F,QAG1G;EAmBC,aAAU;AACR,WAAO,CAAC,KAAK;;EAML,WAAW,KAA6B;AAChD,UAAM,OAAO,KAAK,WAAU;AAC5B,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,KAAK,SAAS,SAAS,UAAU,UAAU,CAAC;AAC9E,UAAM,EAAE,QAAO,IAAK;AAEpB,QAAI,QAAQ,cAAc,KAAK,CAAC,MAAM,SAAS,MAAM,MAAM,UAAU,GAAG;AACtE;;AAEF,QAAI,KAAI;AACR,QAAI,cAAc,QAAQ;AAC1B,QAAI,YAAY,QAAQ;AACxB,QAAI,YAAY,QAAQ;AAGxB,UAAM,SAAS,IAAI,KAAK,gBAAgB,MAAO,KAAK,MAAM;AAE1D,UAAM,eAAe;MACnB,YAAY,QAAQ;MACpB,QAAQ,QAAQ;MAChB,aAAa,QAAQ;;AAEvB,UAAM,WAAW,IAAI,IAAI,MAAM,YAAY,CAAA,CAAE;AAE7C,QAAI,MAAM;AACR,YAAM,MAAM,QAAQ,CAAC,MAAK;AACxB,YAAI,CAAC,SAAS,IAAI,CAAC,GAAG;AACpB,oBAAU,KAAK,cAAc,MAAM,IAAI,MAAM,QAAQ,IAAI,OAAM,IAAK,MAAM,OAAO,CAAC;;MAEtF,CAAC;WACI;AACL,YAAM,MAAM,QAAQ,CAAC,MAAK;AACxB,YAAI,CAAC,SAAS,IAAI,CAAC,GAAG;AACpB,oBAAU,KAAK,cAAc,GAAG,MAAM,IAAI,MAAM,SAAS,IAAI,OAAM,IAAK,MAAM,MAAM;;MAExF,CAAC;;AAEH,QAAI,QAAO;;EAMH,cAAc,KAA6B;AACnD,UAAM,OAAO,KAAK,WAAU;AAC5B,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,KAAK,UAAU,CAAC;AAClD,UAAM,EAAE,QAAO,IAAK;AACpB,QAAI,QAAQ,iBAAiB,KAAK,CAAC,MAAM,YAAY,MAAM,SAAS,WAAW,GAAG;AAChF;;AAEF,QAAI,KAAI;AACR,QAAI,YAAY,QAAQ;AACxB,QAAI,cAAc,QAAQ;AAC1B,QAAI,YAAY,QAAQ;AAExB,UAAM,eAAe;MACnB,YAAY,QAAQ;MACpB,QAAQ,QAAQ;MAChB,aAAa,QAAQ;;AAGvB,QAAI,MAAM;AACR,YAAM,SAAS,QAAQ,CAAC,MAAK;AAC3B,kBAAU,KAAK,cAAc,MAAM,GAAG,CAAC;MACzC,CAAC;WACI;AACL,YAAM,SAAS,QAAQ,CAAC,MAAK;AAC3B,kBAAU,KAAK,cAAc,GAAG,MAAM,CAAC;MACzC,CAAC;;AAGH,QAAI,QAAO;;EAMH,aAAa,KAA6B;AAClD,UAAM,OAAO,KAAK,WAAU;AAC5B,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,KAAK,MAAM,CAAC;AAC9C,UAAM,EAAE,QAAO,IAAK;AACpB,QAAI,QAAQ,cAAc,KAAK,MAAM,QAAQ,QAAQ,OAAO,MAAM,MAAM,IAAI,GAAG;AAC7E;;AAEF,QAAI,KAAI;AACR,QAAI,YAAY,QAAQ;AACxB,QAAI,cAAc,QAAQ;AAC1B,QAAI,YAAY,QAAQ;AAExB,UAAM,eAAe;MACnB,YAAY,QAAQ;MACpB,QAAQ,QAAQ;MAChB,aAAa,QAAQ;;AAGvB,QAAI,MAAM;AACR,gBAAU,KAAK,cAAc,MAAM,GAAG,MAAM,IAAI;WAC3C;AACL,gBAAU,KAAK,cAAc,MAAM,MAAM,MAAM,CAAC;;AAGlD,QAAI,QAAO;;EAOb,WAAW,mBAA2B;AAEpC,WAAO;MACL,MAAM;MACN,KAAK;MACL,OAAO;MACP,QAAQ;;;EAOZ,cAAc,kBAA0B;AACtC,UAAM,UAAU,KAAK,QAAQ;AAC7B,UAAM,IAAI,KAAK,WAAW,gBAAgB;AAC1C,WAAO;MACL,MAAM,EAAE,OAAO;MACf,KAAK,EAAE,MAAM;MACb,OAAO,EAAE,QAAQ;MACjB,QAAQ,EAAE,SAAS;;;EAOvB,QAAQ,QAAgB,QAAgB,kBAA0B;AAChE,QAAI,OAAO,MAAM,KAAK,CAAC,KAAK,OAAO,MAAM,KAAK,CAAC,GAAG;AAChD,aAAO;;AAET,WACE,KAAK,YAAY,QAAQ,QAAQ,gBAAgB,KACjD,KAAK,qBAAqB,QAAQ,QAAQ,gBAAgB,KAAK,QAC/D,KAAK,kBAAkB,QAAQ,QAAQ,gBAAgB,KAAK;;EAOhE,SAAS,QAAgB,kBAA0B;AACjD,UAAM,SAAS,KAAK,cAAc,gBAAgB;AAClD,WAAO,UAAU,OAAO,QAAQ,UAAU,OAAO;;EAMnD,SAAS,QAAgB,kBAA0B;AACjD,UAAM,SAAS,KAAK,cAAc,gBAAgB;AAClD,WAAO,UAAU,OAAO,OAAO,UAAU,OAAO;;EAMxC,qBACR,QACA,QACA,kBAA0B;AAE1B,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,GAAG,GAAG,gBAAgB;AACxD,UAAM,YAAY,KAAK,QAAQ;AAC/B,UAAM,WAAW,KAAK,aAAa,gBAAgB;AACnD,UAAM,WAAW,KAAK,WAAU;AAGhC,QAAK,YAAY,KAAK,IAAI,SAAS,MAAM,CAAC,IAAI,aAAe,CAAC,YAAY,KAAK,IAAI,SAAS,MAAM,CAAC,IAAI,WAAY;AACjH,aAAO;;AAET,UAAM,YAAY,WAAW,SAAS;AACtC,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK,GAAG;AAC3C,UAAI,KAAK,IAAI,SAAS,CAAC,IAAI,SAAS,KAAK,WAAW;AAClD,eAAO,WAAW,EAAE,OAAO,GAAG,GAAG,MAAM,GAAG,GAAG,SAAS,CAAC,EAAC,IAAK,EAAE,OAAO,GAAG,GAAG,SAAS,CAAC,GAAG,GAAG,MAAM,EAAC;;;AAGvG,WAAO;;EAMC,kBACR,QACA,QACA,kBAA0B;AAE1B,UAAM,YAAY,KAAK,QAAQ;AAC/B,QAAI,aAAa,GAAG;AAClB,aAAO;;AAET,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,KAAK,SAAS,SAAS,UAAU,UAAU,GAAG,gBAAgB;AAChG,UAAM,OAAO,KAAK,WAAU;AAC5B,UAAM,EAAE,QAAO,IAAK;AAEpB,QAAI,QAAQ,cAAc,KAAK,CAAC,MAAM,SAAS,MAAM,MAAM,UAAU,GAAG;AACtE,aAAO;;AAIT,UAAM,SAAS,IAAI,KAAK,gBAAgB,MAAO,KAAK,MAAM;AAC1D,UAAM,WAAW,IAAI,IAAI,MAAM,YAAY,CAAA,CAAE;AAE7C,QAAI,MAAM;AACR,eAAS,IAAI,GAAG,IAAI,MAAM,MAAM,QAAQ,KAAK;AAC3C,cAAM,IAAI,MAAM,MAAM,CAAC;AACvB,YAAI,CAAC,SAAS,IAAI,CAAC,GAAG;AACpB,gBAAM,IAAI,MAAM,IAAI,MAAM,QAAQ,IAAI,OAAM,IAAK,MAAM;AACvD,cAAI,KAAK,IAAI,IAAI,MAAM,KAAK,aAAa,KAAK,IAAI,IAAI,MAAM,KAAK,WAAW;AAC1E,mBAAO,EAAE,OAAO,GAAG,GAAG,EAAC;;;;WAIxB;AACL,eAAS,IAAI,GAAG,IAAI,MAAM,MAAM,QAAQ,KAAK;AAC3C,cAAM,IAAI,MAAM,MAAM,CAAC;AACvB,YAAI,CAAC,SAAS,IAAI,CAAC,GAAG;AACpB,gBAAM,IAAI,MAAM,IAAI,MAAM,SAAS,IAAI,OAAM,IAAK,MAAM;AACxD,cAAI,KAAK,IAAI,IAAI,MAAM,KAAK,aAAa,KAAK,IAAI,IAAI,MAAM,KAAK,WAAW;AAC1E,mBAAO,EAAE,OAAO,GAAG,GAAG,EAAC;;;;;AAK/B,WAAO;;EAMC,YAAY,QAAgB,QAAgB,kBAA0B;AAC9E,UAAM,SAAS,KAAK,cAAc,gBAAgB;AAClD,WAAO,UAAU,OAAO,QAAQ,UAAU,OAAO,SAAS,UAAU,OAAO,OAAO,UAAU,OAAO;;EAMrG,eAAe,kBAA0B;AACvC,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,GAAG,GAAG,gBAAgB;AACxD,WAAO;MACL,GAAG,MAAM;MACT,GAAG,MAAM;;;EAOH,aAAa,kBAA0B;AAC/C,UAAM,QAAQ,KAAK,SAAS,CAAC,UAAU,GAAG,gBAAgB;AAC1D,WAAO,MAAM,YAAY,CAAA;;EAM3B,gBACE,eACA,SAAyB;AAEzB,QAAI,CAAC,iBAAiB,OAAO,kBAAkB,WAAW;AAExD,aAAO,KAAK,eAAc;;AAE5B,QAAI,SAAS;AACX,aAAO,QAAQ;AAEf,aAAO,QAAQ;;AAIjB,UAAM,OAAO,KAAK,qBAAqB,cAAc,GAAG,cAAc,CAAC;AACvE,QAAI,QAAQ,QAAQ,SAAS;AAG3B,cAAQ,kBAAkB;QACxB,OAAO,KAAK;QACZ,cAAc,KAAK;;AAErB,aAAO;QACL,GAAG,KAAK;QACR,GAAG,KAAK;;;AAIZ,UAAM,WAAW,KAAK,kBAAkB,cAAc,GAAG,cAAc,CAAC;AACxE,QAAI,YAAY,QAAQ,SAAS;AAG/B,cAAQ,eAAe;QACrB,OAAO,SAAS;QAChB,cAAc,KAAK;;AAErB,aAAO;QACL,GAAG,SAAS;QACZ,GAAG,SAAS;;;AAKhB,WAAO,KAAK,eAAc;;AAE7B;ACxjBM,IAAM,iBAAiB,eAAe,OAAO,CAAC,eAAe,sBAAsB,CAAC;AA6BrF,IAAO,gBAAP,cAA6BC,YAAsD;EAIvF,KAAK,KAA6B;AAChC,QAAI,KAAI;AAER,QAAI,YAAY,KAAK,QAAQ;AAC7B,QAAI,cAAc,KAAK,QAAQ;AAC/B,QAAI,YAAY,KAAK,QAAQ;AAE7B,SAAK,aAAa,GAAG;AACrB,SAAK,cAAc,GAAG;AACtB,SAAK,aAAa,GAAG;AAErB,QAAI,QAAO;AAEX,SAAK,WAAW,GAAG;;EAMX,aAAa,KAA6B;AAClD,QAAI,KAAK,WAAU,GAAI;AACrB,WAAK,qBAAqB,GAAG;WACxB;AACL,WAAK,uBAAuB,GAAG;;;EAOzB,qBAAqB,KAA6B;AAC1D,UAAM,EAAE,QAAO,IAAK;AACpB,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,SAAS,MAAM,MAAM,UAAU,cAAc,YAAY,CAAC;AAE5F,UAAM,EAAE,EAAC,IAAK;AACd,UAAM,EAAE,MAAK,IAAK;AAClB,UAAM,KAAK,IAAI,QAAQ;AAEvB,QAAI,MAAM,KAAK,MAAM,IAAI;AACvB,UAAI,SAAS,IAAI,MAAM,IAAI,OAAO,MAAM,KAAK,MAAM,EAAE;WAChD;AACL,UAAI,SAAS,IAAI,MAAM,IAAI,OAAO,MAAM,KAAK,MAAM,EAAE;;AAIvD,QAAI,KAAI;AACR,QAAI,QAAQ,eAAe,QAAQ,gBAAgB,iBAAiB,QAAQ,gBAAgB,SAAS;AACnG,UAAI,cAAc,QAAQ;;AAE5B,QAAI,UAAS;AACb,QAAI,OAAO,IAAI,MAAM,MAAM;AAC3B,QAAI,OAAO,KAAK,OAAO,MAAM,MAAM;AACnC,QAAI,UAAS;AACb,QAAI,OAAM;AACV,QAAI,QAAO;AAEX,QAAI,KAAI;AAER,QACE,QAAQ,wBACR,QAAQ,yBAAyB,iBACjC,QAAQ,yBAAyB,SACjC;AACA,UAAI,YAAY,QAAQ;AACxB,UAAI,MAAM,KAAK,MAAM,IAAI;AACvB,YAAI,SAAS,IAAI,MAAM,QAAQ,OAAO,MAAM,KAAK,MAAM,MAAM;aACxD;AACL,YAAI,SAAS,IAAI,MAAM,QAAQ,OAAO,MAAM,KAAK,MAAM,MAAM;;;AAGjE,QAAI,QAAO;AAGX,QAAI,MAAM,KAAK,MAAM,IAAI;AACvB,UAAI,WAAW,IAAI,MAAM,IAAI,OAAO,MAAM,KAAK,MAAM,EAAE;WAClD;AACL,UAAI,WAAW,IAAI,MAAM,IAAI,OAAO,MAAM,KAAK,MAAM,EAAE;;AAIzD,QAAI,UAAS;AACb,QAAI,OAAO,IAAI,MAAM,UAAU;AAC/B,QAAI,OAAO,KAAK,OAAO,MAAM,UAAU;AACvC,QAAI,OAAO,GAAG,MAAM,UAAU;AAC9B,QAAI,OAAO,GAAG,MAAM,EAAE;AACtB,QAAI,OAAO,IAAI,MAAM,UAAU;AAC/B,QAAI,OAAO,KAAK,OAAO,MAAM,UAAU;AACvC,QAAI,OAAO,GAAG,MAAM,UAAU;AAC9B,QAAI,OAAO,GAAG,MAAM,EAAE;AACtB,QAAI,UAAS;AACb,QAAI,OAAM;;EAMF,uBAAuB,KAA6B;AAC5D,UAAM,EAAE,QAAO,IAAK;AACpB,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,UAAU,MAAM,MAAM,UAAU,cAAc,YAAY,CAAC;AAE7F,UAAM,EAAE,EAAC,IAAK;AACd,UAAM,EAAE,OAAM,IAAK;AACnB,UAAM,KAAK,IAAI,SAAS;AAGxB,QAAI,MAAM,KAAK,MAAM,IAAI;AACvB,UAAI,SAAS,MAAM,IAAI,IAAI,MAAM,KAAK,MAAM,IAAI,MAAM;WACjD;AACL,UAAI,SAAS,MAAM,IAAI,IAAI,MAAM,KAAK,MAAM,IAAI,MAAM;;AAIxD,QAAI,KAAI;AACR,QAAI,QAAQ,eAAe,QAAQ,gBAAgB,eAAe;AAChE,UAAI,cAAc,QAAQ;;AAE5B,QAAI,UAAS;AACb,QAAI,OAAO,MAAM,QAAQ,EAAE;AAC3B,QAAI,OAAO,MAAM,QAAQ,KAAK,MAAM;AACpC,QAAI,UAAS;AACb,QAAI,OAAM;AACV,QAAI,QAAO;AAEX,QAAI,KAAI;AAER,QAAI,QAAQ,wBAAwB,QAAQ,yBAAyB,eAAe;AAClF,UAAI,YAAY,QAAQ;AACxB,UAAI,MAAM,KAAK,MAAM,IAAI;AACvB,YAAI,SAAS,MAAM,QAAQ,IAAI,MAAM,KAAK,MAAM,QAAQ,MAAM;aACzD;AACL,YAAI,SAAS,MAAM,QAAQ,IAAI,MAAM,KAAK,MAAM,QAAQ,MAAM;;;AAGlE,QAAI,QAAO;AAGX,QAAI,MAAM,KAAK,MAAM,IAAI;AACvB,UAAI,WAAW,MAAM,IAAI,IAAI,MAAM,KAAK,MAAM,IAAI,MAAM;WACnD;AACL,UAAI,WAAW,MAAM,IAAI,IAAI,MAAM,KAAK,MAAM,IAAI,MAAM;;AAI1D,QAAI,UAAS;AACb,QAAI,OAAO,MAAM,YAAY,EAAE;AAC/B,QAAI,OAAO,MAAM,YAAY,KAAK,MAAM;AACxC,QAAI,OAAO,MAAM,YAAY,CAAC;AAC9B,QAAI,OAAO,MAAM,IAAI,CAAC;AACtB,QAAI,OAAO,MAAM,YAAY,EAAE;AAC/B,QAAI,OAAO,MAAM,YAAY,KAAK,MAAM;AACxC,QAAI,OAAO,MAAM,YAAY,CAAC;AAC9B,QAAI,OAAO,MAAM,IAAI,CAAC;AACtB,QAAI,UAAS;AACb,QAAI,OAAM;;EAMZ,WAAW,kBAA0B;AACnC,UAAM,OAAO,KAAK,WAAU;AAC5B,QAAI,KAAK,KAAK,MAAM;AAClB,aAAO;QACL,MAAM;QACN,KAAK;QACL,OAAO;QACP,QAAQ;;;AAIZ,QAAI,MAAM;AACR,YAAM,EAAE,GAAG,OAAO,YAAAC,aAAY,YAAAC,YAAU,IAAK,KAAK,SAChD,CAAC,KAAK,SAAS,cAAc,YAAY,GACzC,gBAAgB;AAElB,YAAM,KAAK,IAAI,QAAQ;AACvB,aAAO;QACL,MAAM;QACN,KAAKD;QACL,OAAO,KAAK;QACZ,QAAQC;;;AAGZ,UAAM,EAAE,GAAG,QAAQ,YAAY,WAAU,IAAK,KAAK,SACjD,CAAC,KAAK,UAAU,cAAc,YAAY,GAC1C,gBAAgB;AAElB,UAAM,KAAK,IAAI,SAAS;AACxB,WAAO;MACL,MAAM;MACN,KAAK;MACL,OAAO;MACP,QAAQ,KAAK;;;;AAIV,cAAE,KAAG;AAKL,cAAA,WAA2B;EAChC,GAAG,WAAW;EACd,GAAGH;EACH,aAAa;EACb,sBAAsB;;AAMjB,cAAa,gBAAmB,EAAE,GAAG,WAAW,eAAe,GAAG,WAAU;AC3O/E,IAAO,SAAP,cAAsBC,YAAqD;EAI/E,KAAK,KAA6B;AAChC,QAAI,KAAI;AAER,QAAI,YAAY,KAAK,QAAQ;AAC7B,QAAI,cAAc,KAAK,QAAQ;AAC/B,QAAI,YAAY,KAAK,QAAQ;AAE7B,UAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,KAAK,UAAU,SAAS,UAAU,OAAO,OAAO,UAAU,aAAa,CAAC;AAE1G,QAAI,MAAM,UAAU,MAAM;AAExB,gBACE,KACA;QACE,YAAY;QACZ,QAAQ;QACR,aAAa,KAAK,QAAQ;SAE5B,MAAM,GACN,MAAM,CAAC;;AAIX,QAAI,MAAM,UAAU,MAAM,OAAO,SAAS,GAAG;AAC3C,WAAK,YAAY,KAAK,KAAK;;AAE7B,SAAK,cAAc,GAAG;AACtB,SAAK,aAAa,GAAG;AAErB,QAAI,QAAO;AAEX,SAAK,WAAW,GAAG;;EAMX,YACR,KACA,OAA2G;AAE3G,QAAI;AACJ,QAAI,MAAM,eAAe,MAAM;AAC7B,oBAAc,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,KAAK,IAAI,GAAG,EAAE,QAAQ,GAAG,OAAO,iBAAiB;WACxF;AACL,oBAAc,MAAM;;AAGtB,QAAI,UAAS;AACb,QAAI,KAAK,WAAU,GAAI;AACrB,YAAM,EAAE,GAAG,MAAK,IAAK;AACrB,YAAM,SAAS,QAAQ,IAAI;AAE3B,YAAM,OAAO,QAAQ,CAAC,MAAK;AACzB,YAAI,OAAO,IAAI,EAAE,WAAW,QAAQ,EAAE,CAAC;MACzC,CAAC;AAED,YAAM,OACH,MAAK,EACL,QAAO,EACP,QAAQ,CAAC,MAAK;AACb,YAAI,OAAO,IAAI,EAAE,WAAW,QAAQ,EAAE,CAAC;MACzC,CAAC;WACE;AACL,YAAM,EAAE,GAAG,OAAM,IAAK;AACtB,YAAM,SAAS,SAAS,IAAI;AAE5B,YAAM,OAAO,QAAQ,CAAC,MAAK;AACzB,YAAI,OAAO,EAAE,GAAG,IAAI,EAAE,WAAW,MAAM;MACzC,CAAC;AAED,YAAM,OACH,MAAK,EACL,QAAO,EACP,QAAQ,CAAC,MAAK;AACb,YAAI,OAAO,EAAE,GAAG,IAAI,EAAE,WAAW,MAAM;MACzC,CAAC;;AAEL,QAAI,UAAS;AACb,QAAI,OAAM;AACV,QAAI,KAAI;;EAMV,WAAW,kBAA0B;AACnC,QAAI,KAAK,WAAU,GAAI;AACrB,YAAM,EAAE,GAAG,OAAO,KAAAG,MAAK,KAAAC,KAAG,IAAK,KAAK,SAAS,CAAC,KAAK,SAAS,OAAO,KAAK,GAAG,gBAAgB;AAC3F,YAAM,KAAK,IAAI,QAAQ;AACvB,aAAO;QACL,MAAM;QACN,KAAKA;QACL,OAAO,KAAK;QACZ,QAAQD;;;AAGZ,UAAM,EAAE,GAAG,QAAQ,KAAK,IAAG,IAAK,KAAK,SAAS,CAAC,KAAK,UAAU,OAAO,KAAK,GAAG,gBAAgB;AAC7F,UAAM,KAAK,IAAI,SAAS;AACxB,WAAO;MACL,MAAM;MACN,KAAK;MACL,OAAO;MACP,QAAQ,KAAK;;;;AAIV,OAAE,KAAG;AAKL,OAAQ,WAAmB,EAAE,GAAG,WAAW,UAAU,GAAGJ,eAAY;AAKpE,OAAa,gBAAmB,EAAE,GAAG,WAAW,eAAe,GAAG,WAAU;AC5IrF,IAAM,gBAAgB;EACpB,OAAO,MAAiC,IAA+B,QAAc;AACnF,QAAI,SAAS,IAAI;AACf,aAAO;;AAET,QAAI,QAAQ,MAAM;AAChB,aAAO;;AAET,QAAI,MAAM,MAAM;AACd,aAAO;;AAET,WAAO,QAAQ,KAAK,QAAQ;;;SAIhB,uBACd,MACA,IACA,QAAc;AAEd,MAAI,OAAO,SAAS,YAAY,OAAO,OAAO,UAAU;AACtD,WAAO,cAAc,OAAO,MAAM,IAAI,MAAM;;AAE9C,MAAI,MAAM,QAAQ,IAAI,KAAK,MAAM,QAAQ,EAAE,GAAG;AAC5C,WAAO,GAAG,IAAI,CAAC,GAAG,MAAM,cAAc,OAAO,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC;;AAElE,SAAO;AACT;SAEgB,qBACd,MACA,IACA,QAAc;AAEd,MAAI,MAAM,QAAQ,IAAI,KAAK,MAAM,QAAQ,EAAE,GAAG;AAC5C,WAAO,GAAG,IAAI,CAAC,GAAG,OAAO;MACvB,GAAG,cAAc,OAAO,KAAK,CAAC,IAAI,KAAK,CAAC,EAAE,IAAI,MAAM,EAAE,GAAG,MAAM;MAC/D,UAAU,cAAc,OAAO,KAAK,CAAC,IAAI,KAAK,CAAC,EAAE,WAAW,MAAM,EAAE,UAAU,MAAM;IACrF,EAAC;;AAEJ,SAAO;AACT;AC3BM,SAAU,sBAEd,MAAuC;AAEvC,QAAM,QAAQ,KAAK;AACnB,QAAM,OAAO;AACb,MAAI,SAAS,KAAK,mBAAmB,QAAQ,KAAK,iBAAiB,KAAK,gBAAgB,cAAc;AACpG,UAAM,sBAAsB,KAAK,gBAAgB;;AAEnD,MAAI,SAAS,KAAK,gBAAgB,QAAQ,KAAK,iBAAiB,KAAK,aAAa,cAAc;AAC9F,UAAM,mBAAmB,KAAK,aAAa;;AAE/C;AAMgB,SAAA,kBAEd,OACA,eAAuC;AAEvC,MAAI,CAAC,MAAM,QAAQ;AACjB,WAAO;;AAET,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,GAAG;AACxC,UAAM,KAAK,MAAM,CAAC,EAAE;AACpB,QAAI,MAAM,GAAG,SAAQ,GAAI;AACvB,YAAM,MAAO,GAAW,gBAAgB,eAAe,IAAI;AAC3D,WAAK,IAAI;AACT,WAAK,IAAI;AACT,eAAS;;;AAGb,SAAO;IACL,GAAG,IAAI;IACP,GAAG,IAAI;;AAEX;AAEA,kBAAkB,KAAK;AACvB,kBAAkB,WAAW,MAAK;AAChC,iBAAQ,YAAY,UAAU;AAC9B,SAAO;AACT;ACxDM,SAA0B,aAAa,MAAc;AACzD,QAAM,YAAY,CAAC,eAAe,iBAAiB,EAAE,OAAO,KAAK,OAAO,CAAC,MAAM,EAAE,SAAS,OAAO,CAAC,CAAC;AACnG,SAAO;IACL,YAAY;MACV,aAAa;QACX,IAAI;QACJ,YAAY,CAAC,YAAY,OAAO;MACjC;MACD,QAAQ;QACN,MAAM;QACN,YAAY;MACb;IACF;IACD,aAAa;MACX,MAAM;QACJ,YAAY;UACV,QAAQ;YACN,MAAM;YACN,YAAY;YACZ,MAAM;UACP;QACF;MACF;MACD,MAAM;QACJ,YAAY;UACV,QAAQ;YACN,MAAM;YACN,YAAY;YACZ,IAAI;UACL;QACF;MACF;IACF;IACD,UAAU;IACV,UAAU;IACV,GAAG;;AAEP;SAEgB,mBAAgB;AAC9B,SAAO;IACL,SAAS;MACP,SAAS;QACP,UAAU,kBAAkB,SAAQ,EAAG;QACvC,WAAW;UACT,aAAa;QACd;MACF;IACF;;AAEL;AAEM,IAAgBC,aAAhB,cAA0F,cAAa;EAUjG,gBAAmB,QAAa,QAAW,QAAwB;AAC3E,eAAW,OAAO,CAAC,OAAO,OAAO,UAAU,MAAM,MAAM,MAAM,GAAG;AAC9D,YAAM,IAAI,OAAO,GAAuB;AACxC,UAAI,OAAO,MAAM,UAAU;AACzB,eAAO,GAAG,IAAI,OAAO,CAAC;;;AAG1B,eAAW,OAAO,CAAC,YAAY,OAAO,GAAG;AACvC,UAAI,MAAM,QAAQ,OAAO,GAAuB,CAAC,GAAG;AAClD,eAAO,GAAG,IAAI,OAAO,GAA2B,EAAE,IAAI,MAAM;;;;EAQlE,UAAU,OAAc,UAA8B;AACpD,UAAM,MAAM,MAAM;AAClB,UAAM,SAAS,KAAK;AAEpB,UAAM,OAAO,OAAO;AACpB,UAAM,EAAE,IAAG,IAAK,MAAM,UAAU,OAAO,QAAQ;AAE/C,UAAM,OAAO,OAAO;AACpB,UAAM,EAAE,IAAG,IAAK,MAAM,UAAU,OAAO,QAAQ;AAE/C,UAAM,OAAO;AACb,WAAO,EAAE,KAAK,IAAG;;EAMnB,mBAAmB,MAAiB,MAAa,OAAe,OAAa;AAC3E,UAAM,SAAS,KAAK;AAEpB,UAAM,SAAS,KAAK;AACpB,UAAM,SAAS,OAAO,UAAS;AAC/B,UAAM,IAAI,CAAA;AACV,aAAS,IAAI,GAAG,IAAI,OAAO,KAAK,GAAG;AACjC,YAAM,QAAQ,IAAI;AAClB,YAAM,SAAc,CAAA;AACpB,aAAO,OAAO,IAAI,IAAI,OAAO,MAAM,OAAO,KAAK,GAAG,KAAK;AACvD,YAAM,QAAQ,KAAK,YAAY,QAAQ,OAAO,OAAO,KAAK,KAAK,GAAG,KAAK,OAAO;AAC9E,UAAI,OAAO;AACT,eAAO,OAAO,QAAQ,KAAK;AAC3B,eAAO,OAAO,IAAI,IAAI,MAAM;;AAE9B,QAAE,KAAK,MAAM;;AAEf,WAAO;;EAMT,eAAe,MAAiB,MAAa,OAAe,OAAa;AACvE,WAAO,KAAK,mBAAmB,MAAM,MAAM,OAAO,KAAK;;EAMzD,gBAAgB,MAAiB,MAAa,OAAe,OAAa;AACxE,WAAO,KAAK,mBAAmB,MAAM,MAAM,OAAO,KAAK;;EAWzD,iBAAiB,OAAa;AAI5B,UAAM,IAAI,MAAM,iBAAiB,KAAK;AACtC,UAAM,EAAE,OAAM,IAAK,KAAK;AACxB,UAAM,SAAS,KAAK,UAAU,KAAK;AACnC,QAAI,CAAC,UAAU,CAAC,UAAU,EAAE,UAAU,OAAO;AAC3C,aAAO;;AAET,MAAE,QAAQ;MACR,KAAK;MACL,qBAAqB;MACrB,kBAAkB;;AAEpB,SAAK,gBAAgB,EAAE,OAAO,QAAQ,CAAC,MAAM,OAAO,iBAAiB,CAAC,CAAC;AACvE,UAAM,IAAI,KAAK,eAAe,EAAE,MAAM,GAAG;AACzC,MAAE,MAAM,WAAW,SAAS,WAAQ;AAElC,UAAI,KAAK,uBAAuB,GAAG;AAEjC,eAAO,aAAa,KAAK,SAAS,KAAK,mBAAmB,CAAC;;AAE7D,UAAI,KAAK,oBAAoB,GAAG;AAE9B,eAAO,UAAU,KAAK,MAAM,KAAK,gBAAgB,CAAC;;AAEpD,aAAO;IACT;AACA,WAAO;;EAOC,eAAe,GAAI;AAC3B,UAAM,IAAI,CAAC,MAAe,KAAK,OAAO,QAAQ,aAAa,GAAG,KAAK,MAAM,QAAQ,QAAS,CAAA,CAAE;AAC5F,WAAO,SAAS,EAAE,EAAE,GAAG,CAAC,mBAAmB,EAAE,EAAE,EAAE,CAAC,aAAa,EAAE,EAAE,MAAM,CAAC,WAAW,EAAE,EAAE,IAAI,CAAC,mBAAmB,EAC/G,EAAE,EAAE,CACL,UAAU,EAAE,EAAE,GAAG,CAAC;;EAOrB,cAAc,WAAoB,OAAe,YAAiB,MAAgB;AAChF,UAAM,QAAQ,SAAS;AACvB,UAAM,QAAQ,KAAK,YAAY;AAC/B,UAAM,SAAS,KAAK,UAAU,KAAK;AACnC,UAAM,OAAO,MAAM,aAAY;AAE/B,eAAW,gBAAgB,KAAK;AAEhC,eAAW,SAAS;AACpB,SAAK,gBAAgB,YAAY,QAAQ,CAAC,MAAO,QAAQ,OAAO,MAAM,iBAAiB,GAAG,KAAK,CAAE;AACjG,UAAM,cAAc,WAAW,OAAO,YAAY,IAAI;;AAEzD;AC3MuB,SAAA,gBACtB,MACA,QACA,YACA,WAA8C,CAAA,GAC9C,SAA4C,CAAA,GAAE;AAE9C,WAAS,eAAe,UAAU;AAClC,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,aAAS,YAAY,GAAG,QAAQ;SAC3B;AACL,aAAS,YAAY,QAAQ;;AAE/B,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,aAAS,UAAU,GAAG,MAAM;SACvB;AACL,aAAS,UAAU,MAAM;;AAE3B,QAAM,IAAI;AACV,IAAE,OAAO;AACT,SAAO;AACT;ACDM,IAAO,oBAAP,cAAiCA,WAA8C;EAKzE,YAAY,OAAgB,QAAuB;AAC3D,WAAO,eAAe,OAAO,MAAM;;EAO3B,gBAAmB,QAAa,QAAkB,QAAwB;AAClF,UAAM,gBAAgB,QAAQ,QAAQ,MAAM;AAC5C,eAAW,OAAO,CAAC,cAAc,YAAY,GAAG;AAC9C,aAAO,GAAG,IAAI,OAAO,OAAO,GAAkC,CAAC;;;;AAInD,kBAAE,KAAG;AAKL,kBAAA,WAAgC,MAAM,CAAA,GAAI;EACxD,cAAc;EACd,aAAa,cAAc;EAC3B;IACE,YAAY;MACV,SAAS;QACP,MAAM;QACN,YAAa,cAAc,SAAiB,WAAW,QAAQ,WAAW,OACxE,CAAC,MAAM,MAAM,OAAO,OAAO,UAAU,cAAc,cAAc,MAAM,GACvE,eAAe,OAAO,CAAC,MAAM,CAAC,EAAE,SAAS,OAAO,CAAC,CAAC;MAErD;IACF;IACD,iBAAiB,cAAc;EAChC;AACF,CAAA;AAKe,kBAAA,YAAiC,MAAM,CAAA,GAAI,CAAE,cAAsB,WAAW,iBAAgB,CAAE,CAAC;AA+B7G,IAAO,eAAP,cAAyF,MAI9F;EAGC,YAAY,MAAiB,QAAgE;AAC3F,UAAM,MAAM,gBAAgB,WAAW,QAAQ,mBAAmB,eAAe,CAAC,aAAa,aAAa,CAAC,CAAC;;;AAHzG,aAAA,KAAK,kBAAkB;AChF1B,IAAO,mBAAP,cAAgCA,WAA4C;EAKtE,YAAY,OAAY,QAAsB;AACtD,WAAO,cAAc,OAAO,MAAM;;EAO1B,gBAAmB,QAAa,QAAiB,QAAwB;AACjF,UAAM,gBAAgB,QAAQ,QAAQ,MAAM;AAE5C,WAAO,cAAc,OAAO;AAC5B,QAAI,MAAM,QAAQ,OAAO,MAAM,GAAG;AAChC,aAAO,SAAS,OAAO,OAAO,IAAI,CAAC,OAAO,EAAE,GAAG,GAAG,GAAG,OAAO,EAAE,CAAC,EAAC,EAAG;;;;AAIvD,iBAAE,KAAG;AAKL,iBAAA,WAAgC,MAAM,CAAA,GAAI;EACxD,cAAc;EACd,aAAa,cAAc;EAC3B;IACE,QAAQ;IACR,YAAY;MACV,SAAS;QACP,MAAM;QACN,YAAa,cAAc,SAAiB,WAAW,QAAQ,WAAW,OACxE,CAAC,MAAM,MAAM,OAAO,OAAO,UAAU,aAAa,GAClD,eAAe,OAAO,CAAC,MAAM,CAAC,EAAE,SAAS,OAAO,CAAC,CAAC;MAErD;MACD,WAAW;QACT,IAAI;QACJ,YAAY,CAAC,QAAQ;MACtB;IACF;IACD,iBAAiB,OAAO;EACzB;AACF,CAAA;AAKe,iBAAA,YAAiC,MAAM,CAAA,GAAI,CAAE,cAAsB,WAAW,iBAAgB,CAAE,CAAC;AA8B7G,IAAO,cAAP,cAAuF,MAI5F;EAGC,YAAY,MAAiB,QAA+D;AAC1F,UAAM,MAAM,gBAAgB,UAAU,QAAQ,kBAAkB,QAAQ,CAAC,aAAa,aAAa,CAAC,CAAC;;;AAHhG,YAAA,KAAK,iBAAiB;",
  "names": ["boxplot", "boxplots", "baseDefaults", "StatsBase", "whiskerMax", "whiskerMin", "min", "max"]
}
